//@version=6
// Combined ICT Structure & Price Action Indicator
// Optimized for white background, mobile-friendly
// Includes: Order Blocks, Breaker Blocks, Propulsion Blocks, FVG/IFVG, MSS/BOS, Displacement, Mitigation Blocks
indicator('ICT Structure & Price Action [Combined]', overlay=true, max_bars_back=5000, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ===================== GLOBAL SETTINGS =====================
var GROUP_GLOBAL = 'Global Settings'
showOB = input.bool(true, 'Show Order Blocks', group=GROUP_GLOBAL)
showBB = input.bool(true, 'Show Breaker Blocks', group=GROUP_GLOBAL)
showPB = input.bool(true, 'Show Propulsion Blocks', group=GROUP_GLOBAL)
showFVG = input.bool(true, 'Show FVG/IFVG', group=GROUP_GLOBAL)
showMSS_BOS = input.bool(true, 'Show MSS/BOS', group=GROUP_GLOBAL)
showDisplacement = input.bool(true, 'Show Displacement', group=GROUP_GLOBAL)
showMB = input.bool(true, 'Show Mitigation Blocks', group=GROUP_GLOBAL)

// ===================== HIGHER TIMEFRAME VISIBILITY CONTROL =====================
// MTF Visibility Rules:
// 1W findings = visible on W & D only
// 1D findings = visible on D, 12H, 8H, 4H (1440 to 240 minutes)
// 4H findings = visible on 4H to 30M (240 to 30 minutes)
// 1H findings = visible on 1H to 5M (60 to 5 minutes)
// 5M findings = visible on 5M to 1M (5 to 1 minutes)
// 1M findings = visible on 5M & 1M only

canShowWeekly() =>
    tf = timeframe.period
    // Only W and D
    tf == 'W' or tf == 'D'

canShowDaily() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1D down to 4H: 1440, 720, 480, 360, 240 (includes D, 12H, 8H, 4H)
    tfInMinutes <= 1440 and tfInMinutes >= 240

canShow4H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 4H down to 30M: 240, 180, 120, 90, 60, 45, 30
    tfInMinutes <= 240 and tfInMinutes >= 30

canShow1H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1H down to 5M: 60, 45, 30, 15, 10, 5
    tfInMinutes <= 60 and tfInMinutes >= 5

canShow5M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 5M down to 1M: 5, 3, 2, 1
    tfInMinutes <= 5 and tfInMinutes >= 1

canShow1M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // Only 5M and 1M
    tfInMinutes == 5 or tfInMinutes == 1

// Determine which timeframe to use for current chart
getCurrentTF() =>
    string result = timeframe.period
    if canShowWeekly()
        result := 'W'
    else if canShowDaily()
        result := 'D'
    else if canShow4H()
        result := '240'
    else if canShow1H()
        result := '60'
    else if canShow5M()
        result := '5'
    else if canShow1M()
        result := '1'
    result

// Check if concept should be visible on current timeframe
shouldShowOnCurrentTF(string conceptTF) =>
    bool show = false
    if conceptTF == 'W'
        show := canShowWeekly()
    else if conceptTF == 'D'
        show := canShowDaily()
    else if conceptTF == '240'
        show := canShow4H()
    else if conceptTF == '60'
        show := canShow1H()
    else if conceptTF == '5'
        show := canShow5M()
    else if conceptTF == '1'
        show := canShow1M()
    else
        show := true  // Default to showing if no specific TF
    show

// ===================== ORDER BLOCKS =====================
var GROUP_OB = 'Order Blocks'
obTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_OB)
obRange = input.int(30, 'Candle Range', minval=5, maxval=100, step=1, group=GROUP_OB)
useMitigatedBlocks = input.bool(false, 'Show Mitigated Blocks', group=GROUP_OB)
bearishOBColour = input.color(color.new(color.red, 70), title='Bearish OB', group=GROUP_OB)
bullishOBColour = input.color(color.new(color.green, 70), title='Bullish OB', group=GROUP_OB)
mitigatedOBColour = input.color(color.new(#808080, 85), title='Mitigated OB', group=GROUP_OB)

// Determine if OB should display
obTF = obTimeframe == '' ? getCurrentTF() : obTimeframe
showOBOnCurrentTF = shouldShowOnCurrentTF(obTF)

// OB Variables - using lines instead of boxes
var longLines = array.new_line()
var longLineStart = array.new_int()
var longLineState = array.new_int()
var longLabels = array.new_label()  // Store labels to delete them later
var longOBHighs = array.new_float()  // Store OB candle highs for BB
var longOBLows = array.new_float()   // Store OB candle lows for BB
var shortLines = array.new_line()
var shortLineStart = array.new_int()
var shortLineState = array.new_int()
var shortLabels = array.new_label()  // Store labels to delete them later
var shortOBHighs = array.new_float()  // Store OB candle highs for BB
var shortOBLows = array.new_float()   // Store OB candle lows for BB

var int lastDownIndex = 0
var float lastDown = 0
var float lastLow = 0
var int lastUpIndex = 0
var float lastUp = 0
var float lastUpLow = 0
var float lastHigh = 0
var int lastLongIndex = 0
var int lastShortIndex = 0

structureLowIndexPointer(len) =>
    float minValue = ta.highest(high, obRange)[1]
    int minIndex = bar_index
    for i = 1 to len
        if low[i] < minValue
            minValue := low[i]
            minIndex := bar_index[i]
    minIndex

float structureLow = ta.lowest(low, obRange)[1]
int structureLowIndex = structureLowIndexPointer(obRange)

// Bearish break of structure - draw horizontal line at OB high
if showOBOnCurrentTF and ta.crossunder(close, structureLow)
    if (bar_index - lastUpIndex) < 1000
        array.push(shortLineStart, bar_index)
        array.push(shortLineState, 0)
        newLine = line.new(lastUpIndex, lastHigh, bar_index + 50, lastHigh, extend=extend.right, color=color.black, width=2, style=line.style_solid)
        newLabel = label.new(x=bar_index, y=lastHigh, text='OB-', color=color.new(color.white, 100), textcolor=color.red, size=size.small, style=label.style_label_lower_right)
        // Hide visuals if OB display is off
        if not showOB
            line.set_color(newLine, color.new(color.black, 100))
            label.delete(newLabel)
            newLabel := label(na)
        array.push(shortLines, newLine)
        array.push(shortLabels, newLabel)
        array.push(shortOBHighs, lastHigh)  // Store high for BB
        array.push(shortOBLows, lastUpLow)  // Store low for BB
        lastShortIndex := lastUpIndex

// Update and check bearish OBs
if showOBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        slabel = array.get(shortLabels, i)
        lstart = array.get(shortLineStart, i)
        lstate = array.get(shortLineState, i)
        lineY = line.get_y1(sline)

        // Check if mitigated (price touched the line)
        if (high > lineY and low < lineY and bar_index > lstart and lstate == 0)
            if useMitigatedBlocks and showOB
                // Delete old line and label, create new ones with mitigated color
                lineX1 = line.get_x1(sline)
                lineX2 = line.get_x2(sline)
                line.delete(sline)
                label.delete(slabel)
                newMitigatedLine = line.new(lineX1, lineY, lineX2, lineY, extend=extend.right, color=mitigatedOBColour, width=2, style=line.style_solid)
                newMitigatedLabel = label.new(x=bar_index, y=lineY, text='OB-', color=color.new(color.white, 100), textcolor=mitigatedOBColour, size=size.small, style=label.style_label_lower_right)
                array.set(shortLines, i, newMitigatedLine)
                array.set(shortLabels, i, newMitigatedLabel)
            else
                // Just delete label if mitigated blocks are off or OB display is off
                label.delete(slabel)
            array.set(shortLineState, i, 1)

        // Remove if price closes above
        if close > lineY
            line.delete(sline)
            label.delete(slabel)
            array.remove(shortLineState, i)
            array.remove(shortLines, i)
            array.remove(shortLabels, i)
            array.remove(shortLineStart, i)
            array.remove(shortOBHighs, i)
            array.remove(shortOBLows, i)

            // Create bullish OB
            if (bar_index - lastDownIndex) < 1000 and bar_index > lastLongIndex
                array.push(longLineStart, bar_index + 1)
                array.push(longLineState, 0)
                newLine = line.new(lastDownIndex, lastLow, bar_index + 50, lastLow, extend=extend.right, color=color.black, width=2, style=line.style_solid)
                newLabel = label.new(x=bar_index, y=lastLow, text='OB+', color=color.new(color.white, 100), textcolor=color.green, size=size.small, style=label.style_label_upper_right)
                // Hide visuals if OB display is off
                if not showOB
                    line.set_color(newLine, color.new(color.black, 100))
                    label.delete(newLabel)
                    newLabel := label(na)
                array.push(longLines, newLine)
                array.push(longLabels, newLabel)
                array.push(longOBHighs, lastDown)  // Store high for BB
                array.push(longOBLows, lastLow)    // Store low for BB
                lastLongIndex := bar_index

// Update bullish order blocks
if showOBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        llabel = array.get(longLabels, i)
        lstart = array.get(longLineStart, i)
        lstate = array.get(longLineState, i)
        lineY = line.get_y1(lline)

        // Check if mitigated (price touched the line)
        if (low <= lineY and high > lineY and bar_index > lstart and lstate == 0)
            if useMitigatedBlocks and showOB
                // Delete old line and label, create new ones with mitigated color
                lineX1 = line.get_x1(lline)
                lineX2 = line.get_x2(lline)
                line.delete(lline)
                label.delete(llabel)
                newMitigatedLine = line.new(lineX1, lineY, lineX2, lineY, extend=extend.right, color=mitigatedOBColour, width=2, style=line.style_solid)
                newMitigatedLabel = label.new(x=bar_index, y=lineY, text='OB+', color=color.new(color.white, 100), textcolor=mitigatedOBColour, size=size.small, style=label.style_label_upper_right)
                array.set(longLines, i, newMitigatedLine)
                array.set(longLabels, i, newMitigatedLabel)
            else
                // Just delete label if mitigated blocks are off or OB display is off
                label.delete(llabel)
            array.set(longLineState, i, 1)

        // Remove if price closes below
        if close < lineY
            array.remove(longLineStart, i)
            array.remove(longLineState, i)
            array.remove(longLines, i)
            label.delete(llabel)
            array.remove(longLabels, i)
            line.delete(lline)
            array.remove(longOBHighs, i)
            array.remove(longOBLows, i)

// Record last up and down candles for OB
if close < open
    lastDown := high
    lastDownIndex := bar_index
    lastLow := low

if close > open
    lastUp := close
    lastUpIndex := bar_index
    lastUpLow := low
    lastHigh := high

lastHigh := high > lastHigh ? high : lastHigh
lastLow := low < lastLow ? low : lastLow

// ===================== BREAKER BLOCKS =====================
var GROUP_BB = 'Breaker Blocks'
bbTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_BB)
bbShowBoxes = input.bool(true, 'Show as Boxes (vs Lines)', group=GROUP_BB, tooltip='Display BBs as boxes with top/bottom or simple lines')
bullishBBColour = input.color(color.new(#089981, 70), title='Bullish BB', group=GROUP_BB)
bearishBBColour = input.color(color.new(#F23645, 70), title='Bearish BB', group=GROUP_BB)

// Determine if BB should display
bbTF = bbTimeframe == '' ? getCurrentTF() : bbTimeframe
showBBOnCurrentTF = shouldShowOnCurrentTF(bbTF)

// BB Variables - using boxes and center lines (LuxAlgo style)
var breakerBoxes = array.new_box()
var breakerCenterLines = array.new_line()
var breakerTypes = array.new_int()  // 1 = bullish, -1 = bearish
var breakerPrices = array.new_float()  // Track the center price level
var breakerTops = array.new_float()
var breakerBottoms = array.new_float()
var breakerLabels = array.new_label()
var breakerMitigated = array.new_bool()  // Track if BB is mitigated

// Detect Breaker Blocks (OB that got broken becomes BB)
// Bullish Breaker: Former bearish OB that price broke above
if showBB and showBBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        slabel = array.get(shortLabels, i)
        lineY = line.get_y1(sline)
        lineLeft = line.get_x1(sline)
        obHigh = array.get(shortOBHighs, i)
        obLow = array.get(shortOBLows, i)

        // If price closes above former bearish OB, it becomes a bullish breaker
        if close > lineY and bar_index > lineLeft + 2
            // Delete the OB
            line.delete(sline)
            label.delete(slabel)
            array.remove(shortLines, i)
            array.remove(shortLabels, i)
            array.remove(shortLineStart, i)
            array.remove(shortLineState, i)
            array.remove(shortOBHighs, i)
            array.remove(shortOBLows, i)

            // Use stored high/low for box dimensions
            bbTop = obHigh
            bbBottom = obLow
            bbCenter = math.avg(bbTop, bbBottom)

            // Create BB box and center line
            if bbShowBoxes
                newBBBox = box.new(lineLeft, bbTop, bar_index + 50, bbBottom, border_color=bullishBBColour, bgcolor=bullishBBColour, extend=extend.right)
                array.push(breakerBoxes, newBBBox)
            else
                newBBBox = box(na)
                array.push(breakerBoxes, newBBBox)

            newBBCenter = line.new(lineLeft, bbCenter, bar_index + 50, bbCenter, extend=extend.right, color=color.new(bullishBBColour, 0), width=2, style=line.style_dashed)
            newBBLabel = label.new(x=bar_index, y=bbCenter, text='BB+', color=color.new(color.white, 100), textcolor=color.green, size=size.small, style=label.style_label_upper_right)

            array.push(breakerCenterLines, newBBCenter)
            array.push(breakerLabels, newBBLabel)
            array.push(breakerTypes, 1)
            array.push(breakerPrices, bbCenter)
            array.push(breakerTops, bbTop)
            array.push(breakerBottoms, bbBottom)
            array.push(breakerMitigated, false)

// Bearish Breaker: Former bullish OB that price broke below
if showBB and showBBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        llabel = array.get(longLabels, i)
        lineY = line.get_y1(lline)
        lineLeft = line.get_x1(lline)
        obHigh = array.get(longOBHighs, i)
        obLow = array.get(longOBLows, i)

        // If price closes below former bullish OB, it becomes a bearish breaker
        if close < lineY and bar_index > lineLeft + 2
            // Delete the OB
            line.delete(lline)
            label.delete(llabel)
            array.remove(longLines, i)
            array.remove(longLabels, i)
            array.remove(longLineStart, i)
            array.remove(longLineState, i)
            array.remove(longOBHighs, i)
            array.remove(longOBLows, i)

            // Use stored high/low for box dimensions
            bbTop = obHigh
            bbBottom = obLow
            bbCenter = math.avg(bbTop, bbBottom)

            // Create BB box and center line
            if bbShowBoxes
                newBBBox = box.new(lineLeft, bbTop, bar_index + 50, bbBottom, border_color=bearishBBColour, bgcolor=bearishBBColour, extend=extend.right)
                array.push(breakerBoxes, newBBBox)
            else
                newBBBox = box(na)
                array.push(breakerBoxes, newBBBox)

            newBBCenter = line.new(lineLeft, bbCenter, bar_index + 50, bbCenter, extend=extend.right, color=color.new(bearishBBColour, 0), width=2, style=line.style_dashed)
            newBBLabel = label.new(x=bar_index, y=bbCenter, text='BB-', color=color.new(color.white, 100), textcolor=color.red, size=size.small, style=label.style_label_lower_right)

            array.push(breakerCenterLines, newBBCenter)
            array.push(breakerLabels, newBBLabel)
            array.push(breakerTypes, -1)
            array.push(breakerPrices, bbCenter)
            array.push(breakerTops, bbTop)
            array.push(breakerBottoms, bbBottom)
            array.push(breakerMitigated, false)

// Update Breaker Blocks - check mitigation
if showBB and showBBOnCurrentTF and array.size(breakerCenterLines) > 0
    for i = (array.size(breakerCenterLines) - 1) to 0
        bbox = array.get(breakerBoxes, i)
        bline = array.get(breakerCenterLines, i)
        blabel = array.get(breakerLabels, i)
        btype = array.get(breakerTypes, i)
        bprice = array.get(breakerPrices, i)
        btop = array.get(breakerTops, i)
        bbottom = array.get(breakerBottoms, i)
        bmitigated = array.get(breakerMitigated, i)

        // Check if BB is mitigated (price closes through the opposite side)
        if not bmitigated
            if btype == 1 and close < bbottom  // Bullish BB mitigated
                array.set(breakerMitigated, i, true)
                // Change visual to indicate mitigation
                if bbShowBoxes
                    bbox.set_bgcolor(color.new(bullishBBColour, 90))
            else if btype == -1 and close > btop  // Bearish BB mitigated
                array.set(breakerMitigated, i, true)
                // Change visual to indicate mitigation
                if bbShowBoxes
                    bbox.set_bgcolor(color.new(bearishBBColour, 90))

        // Remove if completely invalidated
        if (btype == 1 and close < bbottom - ta.atr(14)) or (btype == -1 and close > btop + ta.atr(14))
            if bbShowBoxes
                box.delete(bbox)
            line.delete(bline)
            label.delete(blabel)
            array.remove(breakerBoxes, i)
            array.remove(breakerCenterLines, i)
            array.remove(breakerLabels, i)
            array.remove(breakerTypes, i)
            array.remove(breakerPrices, i)
            array.remove(breakerTops, i)
            array.remove(breakerBottoms, i)
            array.remove(breakerMitigated, i)

// ===================== PROPULSION BLOCKS =====================
var GROUP_PB = 'Propulsion Blocks'
pbTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_PB)
pbShowMeanLine = input.bool(true, 'Show Mean Threshold Line', group=GROUP_PB)
bullishPBColour = input.color(color.new(#089981, 60), title='Bullish PB', group=GROUP_PB)
bearishPBColour = input.color(color.new(#F23645, 60), title='Bearish PB', group=GROUP_PB)

pbTF = pbTimeframe == '' ? getCurrentTF() : pbTimeframe
showPBOnCurrentTF = shouldShowOnCurrentTF(pbTF)

// PB tracking arrays - with breach detection (LuxAlgo style)
var propulsionLines = array.new_line()
var propulsionMeanLines = array.new_line()  // Mean threshold line
var propulsionTypes = array.new_int()  // 1 = bullish, -1 = bearish
var propulsionPrices = array.new_float()  // Track the price level
var propulsionLabels = array.new_label()
var propulsionStarts = array.new_int()

// Breach tracking for each OB
var obBreachingBull = array.new_bool()  // Is bullish OB currently being breached?
var obBreachLowBull = array.new_float()  // Lowest low during breach
var obBreachHighBull = array.new_float()  // Highest high during breach

var obBreachingBear = array.new_bool()  // Is bearish OB currently being breached?
var obBreachLowBear = array.new_float()  // Lowest low during breach
var obBreachHighBear = array.new_float()  // Highest high during breach

// Initialize breach arrays if needed
if array.size(obBreachingBull) < array.size(longLines)
    while array.size(obBreachingBull) < array.size(longLines)
        array.push(obBreachingBull, false)
        array.push(obBreachLowBull, high)
        array.push(obBreachHighBull, low)

if array.size(obBreachingBear) < array.size(shortLines)
    while array.size(obBreachingBear) < array.size(shortLines)
        array.push(obBreachingBear, false)
        array.push(obBreachLowBear, high)
        array.push(obBreachHighBear, low)

// Check for Propulsion Blocks via breach detection
// Bullish OB: When price breaches into OB and makes new high, that high becomes PB
if showPB and showPBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        llabel = array.get(longLabels, i)
        lineY = line.get_y1(lline)
        lineLeft = line.get_x1(lline)
        lstate = array.get(longLineState, i)

        isBreaching = array.get(obBreachingBull, i)
        breachLow = array.get(obBreachLowBull, i)
        breachHigh = array.get(obBreachHighBull, i)

        // Check if price is breaching into the OB zone
        if low <= lineY and high > lineY and bar_index > lineLeft + 1 and lstate == 0 and open > lineY
            if not isBreaching
                // Start tracking breach
                array.set(obBreachingBull, i, true)
                array.set(obBreachLowBull, i, low)
                array.set(obBreachHighBull, i, high)
            else
                // Update breach extremes
                array.set(obBreachLowBull, i, math.min(breachLow, low))
                array.set(obBreachHighBull, i, math.max(breachHigh, high))

        // Check if price propelled upward creating new high
        if isBreaching and close > lineY
            breachHigh := array.get(obBreachHighBull, i)
            // Create PB at the breach high level
            newPB = line.new(lineLeft, breachHigh, bar_index + 50, breachHigh, extend=extend.right, color=bullishPBColour, width=2, style=line.style_solid)
            pbMean = math.avg(breachHigh, lineY)
            newPBMean = line.new(lineLeft, pbMean, bar_index + 50, pbMean, extend=extend.right, color=color.new(bullishPBColour, 50), width=1, style=line.style_dotted)
            newPBLabel = label.new(x=lineLeft, y=breachHigh, text='PB+', color=color.new(color.white, 100), textcolor=color.green, size=size.small, style=label.style_label_upper_right)

            array.push(propulsionLines, newPB)
            array.push(propulsionMeanLines, newPBMean)
            array.push(propulsionLabels, newPBLabel)
            array.push(propulsionTypes, 1)
            array.push(propulsionPrices, breachHigh)
            array.push(propulsionStarts, lineLeft)

            // Remove OB from arrays
            line.delete(lline)
            label.delete(llabel)
            array.remove(longLines, i)
            array.remove(longLabels, i)
            array.remove(longLineStart, i)
            array.remove(longLineState, i)
            array.remove(longOBHighs, i)
            array.remove(longOBLows, i)
            array.remove(obBreachingBull, i)
            array.remove(obBreachLowBull, i)
            array.remove(obBreachHighBull, i)

// Bearish OB: When price breaches into OB and makes new low, that low becomes PB
if showPB and showPBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        slabel = array.get(shortLabels, i)
        lineY = line.get_y1(sline)
        lineLeft = line.get_x1(sline)
        sstate = array.get(shortLineState, i)

        isBreaching = array.get(obBreachingBear, i)
        breachLow = array.get(obBreachLowBear, i)
        breachHigh = array.get(obBreachHighBear, i)

        // Check if price is breaching into the OB zone
        if high >= lineY and low < lineY and bar_index > lineLeft + 1 and sstate == 0 and open < lineY
            if not isBreaching
                // Start tracking breach
                array.set(obBreachingBear, i, true)
                array.set(obBreachLowBear, i, low)
                array.set(obBreachHighBear, i, high)
            else
                // Update breach extremes
                array.set(obBreachLowBear, i, math.min(breachLow, low))
                array.set(obBreachHighBear, i, math.max(breachHigh, high))

        // Check if price propelled downward creating new low
        if isBreaching and close < lineY
            breachLow := array.get(obBreachLowBear, i)
            // Create PB at the breach low level
            newPB = line.new(lineLeft, breachLow, bar_index + 50, breachLow, extend=extend.right, color=bearishPBColour, width=2, style=line.style_solid)
            pbMean = math.avg(breachLow, lineY)
            newPBMean = line.new(lineLeft, pbMean, bar_index + 50, pbMean, extend=extend.right, color=color.new(bearishPBColour, 50), width=1, style=line.style_dotted)
            newPBLabel = label.new(x=lineLeft, y=breachLow, text='PB-', color=color.new(color.white, 100), textcolor=color.red, size=size.small, style=label.style_label_lower_right)

            array.push(propulsionLines, newPB)
            array.push(propulsionMeanLines, newPBMean)
            array.push(propulsionLabels, newPBLabel)
            array.push(propulsionTypes, -1)
            array.push(propulsionPrices, breachLow)
            array.push(propulsionStarts, lineLeft)

            // Remove OB from arrays
            line.delete(sline)
            label.delete(slabel)
            array.remove(shortLines, i)
            array.remove(shortLabels, i)
            array.remove(shortLineStart, i)
            array.remove(shortLineState, i)
            array.remove(shortOBHighs, i)
            array.remove(shortOBLows, i)
            array.remove(obBreachingBear, i)
            array.remove(obBreachLowBear, i)
            array.remove(obBreachHighBear, i)

// Update and clean up Propulsion Blocks
if showPB and showPBOnCurrentTF and array.size(propulsionLines) > 0
    for i = (array.size(propulsionLines) - 1) to 0
        pline = array.get(propulsionLines, i)
        pmean = array.get(propulsionMeanLines, i)
        plabel = array.get(propulsionLabels, i)
        ptype = array.get(propulsionTypes, i)
        pprice = array.get(propulsionPrices, i)

        // Show/hide mean line based on setting
        if not pbShowMeanLine
            line.set_color(pmean, color.new(color.white, 100))

        // Bullish PB invalidated if price closes below it
        if ptype == 1 and close < pprice
            line.delete(pline)
            line.delete(pmean)
            label.delete(plabel)
            array.remove(propulsionLines, i)
            array.remove(propulsionMeanLines, i)
            array.remove(propulsionLabels, i)
            array.remove(propulsionTypes, i)
            array.remove(propulsionPrices, i)
            array.remove(propulsionStarts, i)
        // Bearish PB invalidated if price closes above it
        else if ptype == -1 and close > pprice
            line.delete(pline)
            line.delete(pmean)
            label.delete(plabel)
            array.remove(propulsionLines, i)
            array.remove(propulsionMeanLines, i)
            array.remove(propulsionLabels, i)
            array.remove(propulsionTypes, i)
            array.remove(propulsionPrices, i)
            array.remove(propulsionStarts, i)

// ===================== FVG & IFVG (Fair Value Gaps & Inverse FVG) =====================
var GROUP_FVG = 'Fair Value Gaps & IFVG'
fvgTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_FVG)
fvgLookback = input.int(200, "Lookback Candles", minval=1, maxval=500, group=GROUP_FVG)
maxDrawingDistance = input.int(400, "Max Drawing Distance (bars back)", minval=50, maxval=500, group=GROUP_FVG)
boxLength = input.int(10, "Box Length", minval=1, group=GROUP_FVG)
boxWidth = input.int(1, "Box Border Width", minval=1, maxval=5, group=GROUP_FVG)
showGaps = input.string("Both", "Show Gaps", options=["FVG Only", "IFVG Only", "Both"], group=GROUP_FVG)

// 50% Line Settings
show50Line = input.bool(true, "Show 50% Line", group=GROUP_FVG)
gap50LineWidth = input.int(1,"50% Line Width", minval=1, maxval=5, group=GROUP_FVG)
gap50LineStyleOpt = input.string("Solid", "50% Line Style", options=["Solid", "Dotted", "Dashed"], group=GROUP_FVG)
gap50LineStyle = gap50LineStyleOpt == "Solid" ? line.style_solid : gap50LineStyleOpt == "Dashed" ? line.style_dashed : line.style_dotted

// Color Settings with preferred dark blue backgrounds
bullFVGBorderColor = input.color(color.rgb(76, 175, 79, 100), "Bullish FVG Border", group=GROUP_FVG, inline="bull_fvg")
bullFVGBGColor = input.color(color.new(#0066CC, 90), "Background", group=GROUP_FVG, inline="bull_fvg")
bearFVGBorderColor = input.color(color.rgb(255, 82, 82, 100), "Bearish FVG Border", group=GROUP_FVG, inline="bear_fvg")
bearFVGBGColor = input.color(color.new(#0066CC, 90), "Background", group=GROUP_FVG, inline="bear_fvg")
bullIFVGBorderColor = input.color(color.rgb(0, 0, 0, 100), "Bullish IFVG Border", group=GROUP_FVG, inline="bull_ifvg")
bullIFVGBGColor = input.color(color.new(#0066CC, 90), "Background", group=GROUP_FVG, inline="bull_ifvg")
bearIFVGBorderColor = input.color(color.rgb(0, 0, 0, 100), "Bearish IFVG Border", group=GROUP_FVG, inline="bear_ifvg")
bearIFVGBGColor = input.color(color.new(#0066CC, 90), "Background", group=GROUP_FVG, inline="bear_ifvg")

// Determine if FVG should display
fvgTF = fvgTimeframe == '' ? getCurrentTF() : fvgTimeframe
showFVGOnCurrentTF = shouldShowOnCurrentTF(fvgTF)

// Gap Type Definition
type Gap
    float high
    float low
    bool isBullish
    bool isIFVG
    box gapBox
    line gap50Line
    int createdBar
    bool hasVisuals

// Array to store Gap objects
var array<Gap> gaps = array.new<Gap>()

// Define Bullish/Bearish FVG
isBullishFVG = low > high[2]
bullFVGHigh = low
bullFVGLow = high[2]

isBearishFVG = high < low[2]
bearFVGHigh = low[2]
bearFVGLow = high

// Helper function to create gap visuals
create_gap_visuals(gap) =>
    if bar_index - gap.createdBar <= maxDrawingDistance
        gapMid = (gap.high + gap.low) / 2

        // Set border and background colors
        borderColor = gap.isIFVG ? (gap.isBullish ? bullIFVGBorderColor : bearIFVGBorderColor) : (gap.isBullish ? bullFVGBorderColor : bearFVGBorderColor)
        bgColor = gap.isBullish ? bullFVGBGColor : bearFVGBGColor
        if gap.isIFVG
            bgColor := gap.isBullish ? bullIFVGBGColor : bearIFVGBGColor
        else if showGaps == "IFVG Only"
            bgColor := color.new(bgColor, 100)

        // Create box
        gap.gapBox := box.new(left=gap.createdBar, right=gap.createdBar+boxLength, top=gap.high, bottom=gap.low, border_color=borderColor, bgcolor=bgColor, border_width=boxWidth, xloc=xloc.bar_index)

        // Create 50% line if enabled
        if show50Line
            gap.gap50Line := line.new(x1=gap.createdBar, y1=gapMid, x2=gap.createdBar+boxLength, y2=gapMid, color=color.gray, width=gap50LineWidth, style=gap50LineStyle, xloc=xloc.bar_index)

        gap.hasVisuals := true
    else
        gap.hasVisuals := false

// Helper function to delete gap visuals
delete_gap_visuals(gap) =>
    if gap.hasVisuals
        box.delete(gap.gapBox)
        if not na(gap.gap50Line)
            line.delete(gap.gap50Line)
        gap.hasVisuals := false

// Create new FVG Gap objects
if showFVG and showFVGOnCurrentTF and isBullishFVG and (showGaps == "FVG Only" or showGaps == "Both" or showGaps == "IFVG Only")
    newGap = Gap.new(high = bullFVGHigh, low = bullFVGLow, isBullish = true, isIFVG = false, gapBox = box(na), gap50Line = line(na), createdBar = bar_index-2, hasVisuals = false)
    create_gap_visuals(newGap)
    array.unshift(gaps, newGap)

if showFVG and showFVGOnCurrentTF and isBearishFVG and (showGaps == "FVG Only" or showGaps == "Both" or showGaps == "IFVG Only")
    newGap = Gap.new(high = bearFVGHigh, low = bearFVGLow, isBullish = false, isIFVG = false, gapBox = box(na), gap50Line = line(na), createdBar = bar_index-2, hasVisuals = false)
    create_gap_visuals(newGap)
    array.unshift(gaps, newGap)

// Process existing gaps for invalidation and conversion to IFVG
if showFVG and showFVGOnCurrentTF and array.size(gaps) > 0
    for i = array.size(gaps) - 1 to 0
        gap = array.get(gaps, i)

        if not gap.isIFVG
            // FVG invalidation - convert to opposite IFVG at same timestamp
            if gap.isBullish
                if close < gap.low
                    delete_gap_visuals(gap)
                    if showGaps == "IFVG Only" or showGaps == "Both"
                        newIFVG = Gap.new(high = gap.high, low = gap.low, isBullish = false, isIFVG = true, gapBox = box(na), gap50Line = line(na), createdBar = gap.createdBar, hasVisuals = false)
                        create_gap_visuals(newIFVG)
                        array.set(gaps, i, newIFVG)
                    else
                        array.remove(gaps, i)
            else
                if close > gap.high
                    delete_gap_visuals(gap)
                    if showGaps == "IFVG Only" or showGaps == "Both"
                        newIFVG = Gap.new(high = gap.high, low = gap.low, isBullish = true, isIFVG = true, gapBox = box(na), gap50Line = line(na), createdBar = gap.createdBar, hasVisuals = false)
                        create_gap_visuals(newIFVG)
                        array.set(gaps, i, newIFVG)
                    else
                        array.remove(gaps, i)
        else
            // IFVG invalidation
            if gap.isBullish
                if close < gap.low
                    delete_gap_visuals(gap)
                    array.remove(gaps, i)
            else
                if close > gap.high
                    delete_gap_visuals(gap)
                    array.remove(gaps, i)

// Hide or Remove All 50% Lines If Setting Turned Off
if not show50Line and array.size(gaps) > 0
    for i = 0 to array.size(gaps) - 1
        gap = array.get(gaps, i)
        if gap.hasVisuals and not na(gap.gap50Line)
            line.delete(gap.gap50Line)
            gap.gap50Line := line(na)

// Update visuals for gaps that are now within drawing distance
if array.size(gaps) > 0
    for i = 0 to array.size(gaps) - 1
        gap = array.get(gaps, i)
        if not gap.hasVisuals and bar_index - gap.createdBar <= maxDrawingDistance
            create_gap_visuals(gap)

// Trim array to limit lookback
if array.size(gaps) > fvgLookback
    oldestGap = array.pop(gaps)
    if oldestGap.hasVisuals
        box.delete(oldestGap.gapBox)
        if not na(oldestGap.gap50Line)
            line.delete(oldestGap.gap50Line)

// ===================== MSS & BOS =====================
var GROUP_MSS = 'Market Structure (MSS/BOS)'
tfStructure = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_MSS)
rlBars = input.int(2, 'Swing Bars', 1, group=GROUP_MSS)
showBos = input.bool(true, 'Show BOS', group=GROUP_MSS)
showMss = input.bool(true, 'Show MSS', group=GROUP_MSS)
mssLineColor = input.color(color.black, 'MSS/BOS Line Color', group=GROUP_MSS)

// Determine if MSS/BOS should display
mssTF = tfStructure == '' ? getCurrentTF() : tfStructure
showMSSOnCurrentTF = shouldShowOnCurrentTF(mssTF)

type piv
    float pp
    int pi

var piv pH = na
var piv pL = na
var piv nPh = na
var piv nPl = na
var float nPh1 = na
var float nPl1 = na
var array<line> structLines = array.new_line()
var bool bull = false

Fmtf() =>
    phPs = ta.pivothigh(rlBars, rlBars)
    plPs = ta.pivotlow(rlBars, rlBars)
    int phBi = na
    int plBi = na
    if not na(phPs)
        phBi := time[rlBars]
    if not na(plPs)
        plBi := time[rlBars]
    [phPs, phBi, plPs, plBi]

[phPs, phBi, plPs, plBi] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, Fmtf(), lookahead=barmerge.lookahead_on)

if showMSS_BOS and showMSSOnCurrentTF and not na(phPs)
    nPh := piv.new(phPs, phBi)
    if na(pH)
        pH := piv.new(phPs, phBi)

if showMSS_BOS and showMSSOnCurrentTF and not na(plPs)
    nPl := piv.new(plPs, plBi)
    if na(pL)
        pL := piv.new(plPs, plBi)

var mssBullVar = false
var mssBearVar = false

[htfClose, htfTime] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, [close[1], time[1]], lookahead=barmerge.lookahead_on)
highCond = bull ? high : htfClose
timeHighCond = bull ? time : htfTime

if showMSS_BOS and showMSSOnCurrentTF and (plPs > nPl1 and bull) or na(nPl1) or plPs < nPl1
    nPl1 := plPs

breakHighCond = not na(pH) and highCond > pH.pp

FtfLimit(val) =>
    timeframe.in_seconds() <= timeframe.in_seconds(val == '' ? timeframe.period : val)

var tfL0 = FtfLimit(tfStructure)

if showMSS_BOS and showMSSOnCurrentTF and breakHighCond
    linCon = bull ? showBos : showMss
    isBOS = bull
    if bull
        mssBullVar := false
    else
        mssBullVar := true
    if tfL0 and linCon
        newLine = line.new(pH.pi, pH.pp, timeHighCond, pH.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pH.pi + timeHighCond) / 2)
        label.new(midX, pH.pp, labelText, xloc=xloc.bar_time, style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny, textalign=text.align_center)
    bull := true
    mssBearVar := false
    pH := na
    pL := na
    if not na(nPl1) and not na(nPl)
        pL := piv.new(nPl.pp, nPl.pi)

lowCond = bull ? htfClose : low
timeLowCond = bull ? htfTime : time

if showMSS_BOS and showMSSOnCurrentTF and (phPs < nPh1 and not bull) or na(nPh1) or phPs > nPh1
    nPh1 := phPs

breakLowCond = not na(pL) and lowCond < pL.pp

if showMSS_BOS and showMSSOnCurrentTF and breakLowCond
    linCon = bull ? showMss : showBos
    isBOS = not bull
    if not bull
        mssBearVar := false
    else
        mssBearVar := true
    if tfL0 and linCon
        newLine = line.new(pL.pi, pL.pp, timeLowCond, pL.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pL.pi + timeLowCond) / 2)
        label.new(midX, pL.pp, labelText, xloc=xloc.bar_time, style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny, textalign=text.align_center)
    bull := false
    mssBullVar := false
    pH := na
    pL := na
    if not na(nPh1) and not na(nPh)
        pH := piv.new(nPh.pp, nPh.pi)

// ===================== DISPLACEMENT =====================
var GROUP_DISP = 'Displacement'
dispTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_DISP)
require_fvg_disp = input.bool(false, 'Require FVG', group=GROUP_DISP)
disp_type = input.string('Open to Close', 'Displacement Type', options=['Open to Close', 'High to Low'], group=GROUP_DISP)
std_len = input.int(100, minval=1, title='Displacement Length', group=GROUP_DISP)
std_x = input.int(4, minval=0, title='Displacement Strength', group=GROUP_DISP)
disp_color = input.color(color.yellow, 'Bar Color', group=GROUP_DISP)

// Determine if Displacement should display
dispTF = dispTimeframe == '' ? getCurrentTF() : dispTimeframe
showDispOnCurrentTF = shouldShowOnCurrentTF(dispTF)

candle_range = disp_type == 'Open to Close' ? math.abs(open - close) : high - low
std = ta.stdev(candle_range, std_len) * std_x
fvg_disp = close[1] > open[1] ? high[2] < low[0] : low[2] > high[0]
displacement = require_fvg_disp ? candle_range[1] > std[1] and fvg_disp : candle_range > std

barcolor(showDisplacement and showDispOnCurrentTF and displacement ? disp_color : na, offset=require_fvg_disp ? -1 : na)

// ===================== MITIGATION BLOCKS =====================
var GROUP_MB = 'Mitigation Blocks'
mbTimeframe = input.timeframe('', 'Timeframe for Analysis (Chart)', group=GROUP_MB)
mbShowBull = input.bool(true, 'Show Bullish MB', group=GROUP_MB)
mbShowBear = input.bool(true, 'Show Bearish MB', group=GROUP_MB)
mbBullColor = input.color(color.new(color.green, 85), 'Bullish MB', group=GROUP_MB)
mbBearColor = input.color(color.new(color.red, 85), 'Bearish MB', group=GROUP_MB)
mbLookback = input.int(20, 'Lookback Period', group=GROUP_MB)

// Determine if MB should display
mbTF = mbTimeframe == '' ? getCurrentTF() : mbTimeframe
showMBOnCurrentTF = shouldShowOnCurrentTF(mbTF)

var array<box> mbBullBoxes = array.new_box()
var array<box> mbBearBoxes = array.new_box()

// Detect mitigation blocks
if showMB and showMBOnCurrentTF and mbShowBull
    bullishMB = close[1] > open[1] and low <= low[1] and close > low[1]
    if bullishMB
        mbBullBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBullColor, border_color=color.new(color.green, 100)))
        label.new(bar_index, low[1], 'MB+', style=label.style_label_upper_right, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny)

if showMB and showMBOnCurrentTF and mbShowBear
    bearishMB = close[1] < open[1] and high >= high[1] and close < high[1]
    if bearishMB
        mbBearBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBearColor, border_color=color.new(color.red, 100)))
        label.new(bar_index, high[1], 'MB-', style=label.style_label_lower_right, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny)

// Remove old MB boxes
if mbBullBoxes.size() > mbLookback
    box.delete(mbBullBoxes.shift())

if mbBearBoxes.size() > mbLookback
    box.delete(mbBearBoxes.shift())
