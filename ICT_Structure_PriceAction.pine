//@version=6
// Combined ICT Structure & Price Action Indicator
// Optimized for white background, mobile-friendly
// Includes: Order Blocks, Breaker Blocks, Propulsion Blocks, FVG/IFVG, MSS/BOS, Displacement, Mitigation Blocks
indicator('ICT Structure & Price Action [Combined]', overlay=true, max_bars_back=5000, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ===================== GLOBAL SETTINGS =====================
var GROUP_GLOBAL = 'Global Settings'
showOB = input.bool(true, 'Show Order Blocks', group=GROUP_GLOBAL)
showBB = input.bool(true, 'Show Breaker Blocks', group=GROUP_GLOBAL)
showPB = input.bool(true, 'Show Propulsion Blocks', group=GROUP_GLOBAL)
showFVG = input.bool(true, 'Show FVG/IFVG', group=GROUP_GLOBAL)
showMSS_BOS = input.bool(true, 'Show MSS/BOS', group=GROUP_GLOBAL)
showDisplacement = input.bool(true, 'Show Displacement', group=GROUP_GLOBAL)
showMB = input.bool(true, 'Show Mitigation Blocks', group=GROUP_GLOBAL)

// ===================== HIGHER TIMEFRAME VISIBILITY CONTROL =====================
// MTF Visibility Rules:
// 1W findings = visible on W & D only
// 1D findings = visible on D, 12H, 8H, 4H (1440 to 240 minutes)
// 4H findings = visible on 4H to 30M (240 to 30 minutes)
// 1H findings = visible on 1H to 5M (60 to 5 minutes)
// 5M findings = visible on 5M to 1M (5 to 1 minutes)
// 1M findings = visible on 5M & 1M only

canShowWeekly() =>
    tf = timeframe.period
    // Only W and D
    tf == 'W' or tf == 'D'

canShowDaily() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1D down to 4H: 1440, 720, 480, 360, 240 (includes D, 12H, 8H, 4H)
    tfInMinutes <= 1440 and tfInMinutes >= 240

canShow4H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 4H down to 30M: 240, 180, 120, 90, 60, 45, 30
    tfInMinutes <= 240 and tfInMinutes >= 30

canShow1H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1H down to 5M: 60, 45, 30, 15, 10, 5
    tfInMinutes <= 60 and tfInMinutes >= 5

canShow5M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 5M down to 1M: 5, 3, 2, 1
    tfInMinutes <= 5 and tfInMinutes >= 1

canShow1M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // Only 5M and 1M
    tfInMinutes == 5 or tfInMinutes == 1

// Determine which timeframe to use for current chart
getCurrentTF() =>
    string result = timeframe.period
    if canShowWeekly()
        result := 'W'
    else if canShowDaily()
        result := 'D'
    else if canShow4H()
        result := '240'
    else if canShow1H()
        result := '60'
    else if canShow5M()
        result := '5'
    else if canShow1M()
        result := '1'
    result

// Check if concept should be visible on current timeframe
shouldShowOnCurrentTF(string conceptTF) =>
    bool show = false
    if conceptTF == 'W'
        show := canShowWeekly()
    else if conceptTF == 'D'
        show := canShowDaily()
    else if conceptTF == '240'
        show := canShow4H()
    else if conceptTF == '60'
        show := canShow1H()
    else if conceptTF == '5'
        show := canShow5M()
    else if conceptTF == '1'
        show := canShow1M()
    else
        show := true  // Default to showing if no specific TF
    show

// ===================== ORDER BLOCKS =====================
var GROUP_OB = 'Order Blocks'
obTimeframe = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_OB)
obRange = input.int(30, 'Candle Range', minval=5, maxval=100, step=1, group=GROUP_OB)
useMitigatedBlocks = input.bool(true, 'Show Mitigated Blocks', group=GROUP_OB)
bearishOBColour = input.color(color.new(color.red, 70), title='Bearish OB', group=GROUP_OB)
bullishOBColour = input.color(color.new(color.green, 70), title='Bullish OB', group=GROUP_OB)
mitigatedOBColour = input.color(color.new(#808080, 85), title='Mitigated OB', group=GROUP_OB)

// Determine if OB should display
obTF = obTimeframe == '' ? getCurrentTF() : obTimeframe
showOBOnCurrentTF = shouldShowOnCurrentTF(obTF)

// OB Variables - using lines instead of boxes
var longLines = array.new_line()
var longLineStart = array.new_int()
var longLineState = array.new_int()
var shortLines = array.new_line()
var shortLineStart = array.new_int()
var shortLineState = array.new_int()

var int lastDownIndex = 0
var float lastDown = 0
var float lastLow = 0
var int lastUpIndex = 0
var float lastUp = 0
var float lastUpLow = 0
var float lastHigh = 0
var int lastLongIndex = 0
var int lastShortIndex = 0

structureLowIndexPointer(len) =>
    float minValue = ta.highest(high, obRange)[1]
    int minIndex = bar_index
    for i = 1 to len
        if low[i] < minValue
            minValue := low[i]
            minIndex := bar_index[i]
    minIndex

float structureLow = ta.lowest(low, obRange)[1]
int structureLowIndex = structureLowIndexPointer(obRange)

// Bearish break of structure - draw horizontal line at OB high
if showOB and showOBOnCurrentTF and ta.crossunder(close, structureLow)
    if (bar_index - lastUpIndex) < 1000
        array.push(shortLineStart, bar_index)
        array.push(shortLineState, 0)
        newLine = line.new(x1=lastUpIndex, y1=lastHigh, x2=bar_index + 50, y2=lastHigh, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='OB-', text_color=color.red, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
        array.push(shortLines, newLine)
        lastShortIndex := lastUpIndex

// Bullish break of structure - draw horizontal line at OB low
if showOB and showOBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        lstart = array.get(shortLineStart, i)
        lstate = array.get(shortLineState, i)
        lineY = line.get_y1(sline)

        // Check if mitigated (price touched the line)
        if (high > lineY and low < lineY and bar_index > lstart and lstate == 0 and useMitigatedBlocks)
            // Delete old line and create new one with mitigated color
            lineX1 = line.get_x1(sline)
            lineX2 = line.get_x2(sline)
            line.delete(sline)
            newMitigatedLine = line.new(x1=lineX1, y1=lineY, x2=lineX2, y2=lineY, extend=extend.right, color=mitigatedOBColour, width=2, style=line.style_solid, text='OB-', text_color=mitigatedOBColour, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
            array.set(shortLines, i, newMitigatedLine)
            array.set(shortLineState, i, 1)

        // Remove if price closes above
        if close > lineY
            line.delete(sline)
            array.remove(shortLineState, i)
            array.remove(shortLines, i)
            array.remove(shortLineStart, i)

            // Create bullish OB
            if (bar_index - lastDownIndex) < 1000 and bar_index > lastLongIndex
                array.push(longLineStart, bar_index + 1)
                array.push(longLineState, 0)
                newLine = line.new(x1=lastDownIndex, y1=lastLow, x2=bar_index + 50, y2=lastLow, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='OB+', text_color=color.green, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
                array.push(longLines, newLine)
                lastLongIndex := bar_index

// Update bullish order blocks
if showOB and showOBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        lstart = array.get(longLineStart, i)
        lstate = array.get(longLineState, i)
        lineY = line.get_y1(lline)

        // Check if mitigated (price touched the line)
        if (low <= lineY and high > lineY and bar_index > lstart and lstate == 0)
            if useMitigatedBlocks
                // Delete old line and create new one with mitigated color
                lineX1 = line.get_x1(lline)
                lineX2 = line.get_x2(lline)
                line.delete(lline)
                newMitigatedLine = line.new(x1=lineX1, y1=lineY, x2=lineX2, y2=lineY, extend=extend.right, color=mitigatedOBColour, width=2, style=line.style_solid, text='OB+', text_color=mitigatedOBColour, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
                array.set(longLines, i, newMitigatedLine)
            array.set(longLineState, i, 1)

        // Remove if price closes below
        if close < lineY
            array.remove(longLineStart, i)
            array.remove(longLineState, i)
            array.remove(longLines, i)
            line.delete(lline)

// Record last up and down candles for OB
if close < open
    lastDown := high
    lastDownIndex := bar_index
    lastLow := low

if close > open
    lastUp := close
    lastUpIndex := bar_index
    lastUpLow := low
    lastHigh := high

lastHigh := high > lastHigh ? high : lastHigh
lastLow := low < lastLow ? low : lastLow

// ===================== BREAKER BLOCKS =====================
var GROUP_BB = 'Breaker Blocks'
bbTimeframe = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_BB)
bullishBBColour = input.color(color.new(#2196F3, 70), title='Bullish BB', group=GROUP_BB)
bearishBBColour = input.color(color.new(#FF9800, 70), title='Bearish BB', group=GROUP_BB)

// Determine if BB should display
bbTF = bbTimeframe == '' ? getCurrentTF() : bbTimeframe
showBBOnCurrentTF = shouldShowOnCurrentTF(bbTF)

// BB Variables - using lines instead of boxes
var breakerLines = array.new_line()
var breakerTypes = array.new_int()  // 1 = bullish, -1 = bearish
var breakerStarts = array.new_int()
var breakerPrices = array.new_float()  // Track the price level

// Detect Breaker Blocks (OB that got broken becomes BB)
// Bullish Breaker: Former bearish OB that price broke above
if showBB and showBBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        lineY = line.get_y1(sline)
        lineLeft = line.get_x1(sline)

        // If price closes above former bearish OB, it becomes a bullish breaker
        if close > lineY and bar_index > lineLeft + 2
            // Create breaker line
            newBB = line.new(x1=lineLeft, y1=lineY, x2=bar_index + 50, y2=lineY, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='BB+', text_color=color.green, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
            array.push(breakerLines, newBB)
            array.push(breakerTypes, 1)
            array.push(breakerStarts, bar_index)
            array.push(breakerPrices, lineY)

// Bearish Breaker: Former bullish OB that price broke below
if showBB and showBBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        lineY = line.get_y1(lline)
        lineLeft = line.get_x1(lline)

        // If price closes below former bullish OB, it becomes a bearish breaker
        if close < lineY and bar_index > lineLeft + 2
            // Create breaker line
            newBB = line.new(x1=lineLeft, y1=lineY, x2=bar_index + 50, y2=lineY, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='BB-', text_color=color.red, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
            array.push(breakerLines, newBB)
            array.push(breakerTypes, -1)
            array.push(breakerStarts, bar_index)
            array.push(breakerPrices, lineY)

// Update and remove invalidated breaker blocks
if showBB and showBBOnCurrentTF and array.size(breakerLines) > 0
    for i = (array.size(breakerLines) - 1) to 0
        bline = array.get(breakerLines, i)
        btype = array.get(breakerTypes, i)
        bprice = array.get(breakerPrices, i)

        // Bullish breaker invalidated if price closes below it
        if btype == 1 and close < bprice
            line.delete(bline)
            array.remove(breakerLines, i)
            array.remove(breakerTypes, i)
            array.remove(breakerStarts, i)
            array.remove(breakerPrices, i)
        // Bearish breaker invalidated if price closes above it
        else if btype == -1 and close > bprice
            line.delete(bline)
            array.remove(breakerLines, i)
            array.remove(breakerTypes, i)
            array.remove(breakerStarts, i)
            array.remove(breakerPrices, i)

// ===================== PROPULSION BLOCKS =====================
var GROUP_PB = 'Propulsion Blocks'
pbTimeframe = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_PB)
pbMultiplier = input.float(2.0, 'Propulsion Multiplier', minval=1.0, step=0.5, group=GROUP_PB, tooltip='Price must move this many times the OB size to become a PB')
bullishPBColour = input.color(color.new(#089981, 60), title='Bullish PB', group=GROUP_PB)
bearishPBColour = input.color(color.new(#F23645, 60), title='Bearish PB', group=GROUP_PB)

pbTF = pbTimeframe == '' ? getCurrentTF() : pbTimeframe
showPBOnCurrentTF = shouldShowOnCurrentTF(pbTF)

// PB tracking arrays - using lines instead of boxes
var propulsionLines = array.new_line()
var propulsionTypes = array.new_int()  // 1 = bullish, -1 = bearish
var propulsionPrices = array.new_float()  // Track the price level

// Check if existing OBs become Propulsion Blocks
// Bullish OB becomes PB when tested and price propels upward
if showPB and showPBOnCurrentTF and array.size(longLines) > 0
    for i = (array.size(longLines) - 1) to 0
        lline = array.get(longLines, i)
        lineY = line.get_y1(lline)
        lineLeft = line.get_x1(lline)

        // Check if price tested this OB (touched it)
        if low <= lineY and high >= lineY and bar_index > lineLeft + 1
            // Check if price then propelled upward (strong move)
            // For PB, we need a reference range - using ATR or fixed percentage
            propulsionThreshold = lineY * (1 + (pbMultiplier / 100))  // 2% default
            if high > propulsionThreshold
                // This OB became a Propulsion Block
                newPB = line.new(x1=lineLeft, y1=lineY, x2=bar_index + 50, y2=lineY, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='PB+', text_color=color.green, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
                array.push(propulsionLines, newPB)
                array.push(propulsionTypes, 1)
                array.push(propulsionPrices, lineY)

                // Remove from regular OB array
                line.delete(lline)
                array.remove(longLines, i)
                array.remove(longLineStart, i)
                array.remove(longLineState, i)

// Bearish OB becomes PB when tested and price propels downward
if showPB and showPBOnCurrentTF and array.size(shortLines) > 0
    for i = (array.size(shortLines) - 1) to 0
        sline = array.get(shortLines, i)
        lineY = line.get_y1(sline)
        lineLeft = line.get_x1(sline)

        // Check if price tested this OB
        if low <= lineY and high >= lineY and bar_index > lineLeft + 1
            // Check if price then propelled downward
            propulsionThreshold = lineY * (1 - (pbMultiplier / 100))
            if low < propulsionThreshold
                // This OB became a Propulsion Block
                newPB = line.new(x1=lineLeft, y1=lineY, x2=bar_index + 50, y2=lineY, extend=extend.right, color=color.black, width=2, style=line.style_solid, text='PB-', text_color=color.red, text_size=size.small, text_halign=text.align_right, text_valign=text.align_top)
                array.push(propulsionLines, newPB)
                array.push(propulsionTypes, -1)
                array.push(propulsionPrices, lineY)

                // Remove from regular OB array
                line.delete(sline)
                array.remove(shortLines, i)
                array.remove(shortLineStart, i)
                array.remove(shortLineState, i)

// Update and clean up old Propulsion Blocks
if showPB and showPBOnCurrentTF and array.size(propulsionLines) > 0
    for i = (array.size(propulsionLines) - 1) to 0
        pline = array.get(propulsionLines, i)
        ptype = array.get(propulsionTypes, i)
        pprice = array.get(propulsionPrices, i)

        // Bullish PB invalidated if price closes below it
        if ptype == 1 and close < pprice
            line.delete(pline)
            array.remove(propulsionLines, i)
            array.remove(propulsionTypes, i)
            array.remove(propulsionPrices, i)
        // Bearish PB invalidated if price closes above it
        else if ptype == -1 and close > pprice
            line.delete(pline)
            array.remove(propulsionLines, i)
            array.remove(propulsionTypes, i)
            array.remove(propulsionPrices, i)

// ===================== FVG (Fair Value Gaps) =====================
var GROUP_FVG = 'Fair Value Gaps'
fvgTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_FVG)
fvgValidityPeriod = input.int(500, 'FVG Validity Period (Bars)', group=GROUP_FVG, maxval=4998, minval=10)
fvgColor = input.color(color.new(#00BFFF, 80), 'FVG Color (Light Blue)', group=GROUP_FVG)

// Determine if FVG should display
fvgTF = fvgTimeframe == '' ? getCurrentTF() : fvgTimeframe
showFVGOnCurrentTF = shouldShowOnCurrentTF(fvgTF)

// FVG Detection
bullishFVG = close > open and close[1] > open[1] and high[2] < low[0]
bearishFVG = close < open and close[1] < open[1] and low[2] > high[0]

var array<box> fvgBoxes = array.new_box()
var array<int> fvgBars = array.new_int()

// Create FVG boxes - NO labels, borders, middle lines, or text - just clean filled boxes
if showFVG and showFVGOnCurrentTF and bullishFVG
    fvgBoxes.push(box.new(bar_index[2], low[0], bar_index, high[2], bgcolor=fvgColor, border_color=color.new(#00BFFF, 100)))
    fvgBars.push(bar_index)

if showFVG and showFVGOnCurrentTF and bearishFVG
    fvgBoxes.push(box.new(bar_index[2], low[2], bar_index, high[0], bgcolor=fvgColor, border_color=color.new(#00BFFF, 100)))
    fvgBars.push(bar_index)

// Remove old FVG boxes
if fvgBoxes.size() > 0
    for i = fvgBoxes.size() - 1 to 0
        fvgBox = fvgBoxes.get(i)
        fvgTop = box.get_top(fvgBox)
        fvgBot = box.get_bottom(fvgBox)
        if bar_index - fvgBars.get(i) > fvgValidityPeriod or (low <= fvgTop and high >= fvgBot)
            box.delete(fvgBox)
            fvgBoxes.remove(i)
            fvgBars.remove(i)

// ===================== MSS & BOS =====================
var GROUP_MSS = 'Market Structure (MSS/BOS)'
tfStructure = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_MSS)
rlBars = input.int(2, 'Swing Bars', 1, group=GROUP_MSS)
showBos = input.bool(true, 'Show BOS', group=GROUP_MSS)
showMss = input.bool(true, 'Show MSS', group=GROUP_MSS)
mssLineColor = input.color(color.black, 'MSS/BOS Line Color', group=GROUP_MSS)

// Determine if MSS/BOS should display
mssTF = tfStructure == '' ? getCurrentTF() : tfStructure
showMSSOnCurrentTF = shouldShowOnCurrentTF(mssTF)

type piv
    float pp
    int pi

var piv pH = na
var piv pL = na
var piv nPh = na
var piv nPl = na
var float nPh1 = na
var float nPl1 = na
var array<line> structLines = array.new_line()
var bool bull = false

Fmtf() =>
    phPs = ta.pivothigh(rlBars, rlBars)
    plPs = ta.pivotlow(rlBars, rlBars)
    int phBi = na
    int plBi = na
    if not na(phPs)
        phBi := time[rlBars]
    if not na(plPs)
        plBi := time[rlBars]
    [phPs, phBi, plPs, plBi]

[phPs, phBi, plPs, plBi] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, Fmtf(), lookahead=barmerge.lookahead_on)

if showMSS_BOS and showMSSOnCurrentTF and not na(phPs)
    nPh := piv.new(phPs, phBi)
    if na(pH)
        pH := piv.new(phPs, phBi)

if showMSS_BOS and showMSSOnCurrentTF and not na(plPs)
    nPl := piv.new(plPs, plBi)
    if na(pL)
        pL := piv.new(plPs, plBi)

var mssBullVar = false
var mssBearVar = false

[htfClose, htfTime] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, [close[1], time[1]], lookahead=barmerge.lookahead_on)
highCond = bull ? high : htfClose
timeHighCond = bull ? time : htfTime

if showMSS_BOS and showMSSOnCurrentTF and (plPs > nPl1 and bull) or na(nPl1) or plPs < nPl1
    nPl1 := plPs

breakHighCond = not na(pH) and highCond > pH.pp

FtfLimit(val) =>
    timeframe.in_seconds() <= timeframe.in_seconds(val == '' ? timeframe.period : val)

var tfL0 = FtfLimit(tfStructure)

if showMSS_BOS and showMSSOnCurrentTF and breakHighCond
    linCon = bull ? showBos : showMss
    isBOS = bull
    if bull
        mssBullVar := false
    else
        mssBullVar := true
    if tfL0 and linCon
        newLine = line.new(pH.pi, pH.pp, timeHighCond, pH.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pH.pi + timeHighCond) / 2)
        label.new(midX, pH.pp, labelText, xloc=xloc.bar_time, style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny, textalign=text.align_center)
    bull := true
    mssBearVar := false
    pH := na
    pL := na
    if not na(nPl1) and not na(nPl)
        pL := piv.new(nPl.pp, nPl.pi)

lowCond = bull ? htfClose : low
timeLowCond = bull ? htfTime : time

if showMSS_BOS and showMSSOnCurrentTF and (phPs < nPh1 and not bull) or na(nPh1) or phPs > nPh1
    nPh1 := phPs

breakLowCond = not na(pL) and lowCond < pL.pp

if showMSS_BOS and showMSSOnCurrentTF and breakLowCond
    linCon = bull ? showMss : showBos
    isBOS = not bull
    if not bull
        mssBearVar := false
    else
        mssBearVar := true
    if tfL0 and linCon
        newLine = line.new(pL.pi, pL.pp, timeLowCond, pL.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pL.pi + timeLowCond) / 2)
        label.new(midX, pL.pp, labelText, xloc=xloc.bar_time, style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny, textalign=text.align_center)
    bull := false
    mssBullVar := false
    pH := na
    pL := na
    if not na(nPh1) and not na(nPh)
        pH := piv.new(nPh.pp, nPh.pi)

// ===================== DISPLACEMENT =====================
var GROUP_DISP = 'Displacement'
dispTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_DISP)
require_fvg_disp = input.bool(false, 'Require FVG', group=GROUP_DISP)
disp_type = input.string('Open to Close', 'Displacement Type', options=['Open to Close', 'High to Low'], group=GROUP_DISP)
std_len = input.int(100, minval=1, title='Displacement Length', group=GROUP_DISP)
std_x = input.int(4, minval=0, title='Displacement Strength', group=GROUP_DISP)
disp_color = input.color(color.yellow, 'Bar Color', group=GROUP_DISP)

// Determine if Displacement should display
dispTF = dispTimeframe == '' ? getCurrentTF() : dispTimeframe
showDispOnCurrentTF = shouldShowOnCurrentTF(dispTF)

candle_range = disp_type == 'Open to Close' ? math.abs(open - close) : high - low
std = ta.stdev(candle_range, std_len) * std_x
fvg_disp = close[1] > open[1] ? high[2] < low[0] : low[2] > high[0]
displacement = require_fvg_disp ? candle_range[1] > std[1] and fvg_disp : candle_range > std

barcolor(showDisplacement and showDispOnCurrentTF and displacement ? disp_color : na, offset=require_fvg_disp ? -1 : na)

// ===================== MITIGATION BLOCKS =====================
var GROUP_MB = 'Mitigation Blocks'
mbTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_MB)
mbShowBull = input.bool(true, 'Show Bullish MB', group=GROUP_MB)
mbShowBear = input.bool(true, 'Show Bearish MB', group=GROUP_MB)
mbBullColor = input.color(color.new(color.green, 85), 'Bullish MB', group=GROUP_MB)
mbBearColor = input.color(color.new(color.red, 85), 'Bearish MB', group=GROUP_MB)
mbLookback = input.int(20, 'Lookback Period', group=GROUP_MB)

// Determine if MB should display
mbTF = mbTimeframe == '' ? getCurrentTF() : mbTimeframe
showMBOnCurrentTF = shouldShowOnCurrentTF(mbTF)

var array<box> mbBullBoxes = array.new_box()
var array<box> mbBearBoxes = array.new_box()

// Detect mitigation blocks
if showMB and showMBOnCurrentTF and mbShowBull
    bullishMB = close[1] > open[1] and low <= low[1] and close > low[1]
    if bullishMB
        mbBullBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBullColor, border_color=color.new(color.green, 100)))
        label.new(bar_index, low[1], 'MB+', style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny)

if showMB and showMBOnCurrentTF and mbShowBear
    bearishMB = close[1] < open[1] and high >= high[1] and close < high[1]
    if bearishMB
        mbBearBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBearColor, border_color=color.new(color.red, 100)))
        label.new(bar_index, high[1], 'MB-', style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny)

// Remove old MB boxes
if mbBullBoxes.size() > mbLookback
    box.delete(mbBullBoxes.shift())

if mbBearBoxes.size() > mbLookback
    box.delete(mbBearBoxes.shift())
