//@version=6
// Combined ICT Structure & Price Action Indicator
// Optimized for white background, mobile-friendly
// Includes: Order Blocks, Breaker Blocks, FVG/IFVG, MSS/BOS, Displacement, Mitigation Blocks
indicator('ICT Structure & Price Action [Combined]', overlay=true, max_bars_back=5000, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ===================== GLOBAL SETTINGS =====================
var GROUP_GLOBAL = 'Global Settings'
showOB = input.bool(true, 'Show Order Blocks', group=GROUP_GLOBAL)
showBB = input.bool(true, 'Show Breaker Blocks', group=GROUP_GLOBAL)
showFVG = input.bool(true, 'Show FVG/IFVG', group=GROUP_GLOBAL)
showMSS_BOS = input.bool(true, 'Show MSS/BOS', group=GROUP_GLOBAL)
showDisplacement = input.bool(true, 'Show Displacement', group=GROUP_GLOBAL)
showMB = input.bool(true, 'Show Mitigation Blocks', group=GROUP_GLOBAL)

// ===================== HIGHER TIMEFRAME VISIBILITY CONTROL =====================
// MTF Visibility Rules:
// 1W findings = visible on W & D only
// 1D findings = visible on D, 12H, 8H, 4H (1440 to 240 minutes)
// 4H findings = visible on 4H to 30M (240 to 30 minutes)
// 1H findings = visible on 1H to 5M (60 to 5 minutes)
// 5M findings = visible on 5M to 1M (5 to 1 minutes)
// 1M findings = visible on 5M & 1M only

canShowWeekly() =>
    tf = timeframe.period
    // Only W and D
    tf == 'W' or tf == 'D'

canShowDaily() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1D down to 4H: 1440, 720, 480, 360, 240 (includes D, 12H, 8H, 4H)
    tfInMinutes <= 1440 and tfInMinutes >= 240

canShow4H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 4H down to 30M: 240, 180, 120, 90, 60, 45, 30
    tfInMinutes <= 240 and tfInMinutes >= 30

canShow1H() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 1H down to 5M: 60, 45, 30, 15, 10, 5
    tfInMinutes <= 60 and tfInMinutes >= 5

canShow5M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // 5M down to 1M: 5, 3, 2, 1
    tfInMinutes <= 5 and tfInMinutes >= 1

canShow1M() =>
    tfInMinutes = timeframe.in_seconds() / 60
    // Only 5M and 1M
    tfInMinutes == 5 or tfInMinutes == 1

// Determine which timeframe to use for current chart
getCurrentTF() =>
    string result = timeframe.period
    if canShowWeekly()
        result := 'W'
    else if canShowDaily()
        result := 'D'
    else if canShow4H()
        result := '240'
    else if canShow1H()
        result := '60'
    else if canShow5M()
        result := '5'
    else if canShow1M()
        result := '1'
    result

// Check if concept should be visible on current timeframe
shouldShowOnCurrentTF(string conceptTF) =>
    bool show = false
    if conceptTF == 'W'
        show := canShowWeekly()
    else if conceptTF == 'D'
        show := canShowDaily()
    else if conceptTF == '240'
        show := canShow4H()
    else if conceptTF == '60'
        show := canShow1H()
    else if conceptTF == '5'
        show := canShow5M()
    else if conceptTF == '1'
        show := canShow1M()
    else
        show := true  // Default to showing if no specific TF
    show

// ===================== ORDER BLOCKS =====================
var GROUP_OB = 'Order Blocks'
obTimeframe = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_OB)
obRange = input.int(30, 'Candle Range', minval=5, maxval=100, step=1, group=GROUP_OB)
useMitigatedBlocks = input.bool(true, 'Show Mitigated Blocks', group=GROUP_OB)
bearishOBColour = input.color(color.new(color.red, 70), title='Bearish OB', group=GROUP_OB)
bullishOBColour = input.color(color.new(color.green, 70), title='Bullish OB', group=GROUP_OB)
mitigatedOBColour = input.color(color.new(#808080, 85), title='Mitigated OB', group=GROUP_OB)

// Determine if OB should display
obTF = obTimeframe == '' ? getCurrentTF() : obTimeframe
showOBOnCurrentTF = shouldShowOnCurrentTF(obTF)

// OB Variables
var longBoxes = array.new_box()
var longBoxStart = array.new_int()
var longBoxState = array.new_int()
var shortBoxes = array.new_box()
var shortBoxStart = array.new_int()
var shortBoxState = array.new_int()

var int lastDownIndex = 0
var float lastDown = 0
var float lastLow = 0
var int lastUpIndex = 0
var float lastUp = 0
var float lastUpLow = 0
var float lastHigh = 0
var int lastLongIndex = 0
var int lastShortIndex = 0

structureLowIndexPointer(len) =>
    float minValue = ta.highest(high, obRange)[1]
    int minIndex = bar_index
    for i = 1 to len
        if low[i] < minValue
            minValue := low[i]
            minIndex := bar_index[i]
    minIndex

float structureLow = ta.lowest(low, obRange)[1]
int structureLowIndex = structureLowIndexPointer(obRange)

// Bearish break of structure
if showOB and showOBOnCurrentTF and ta.crossunder(close, structureLow)
    if (bar_index - lastUpIndex) < 1000
        array.push(shortBoxStart, bar_index)
        array.push(shortBoxState, 0)
        newBox = box.new(left=lastUpIndex, top=lastHigh, bottom=lastUpLow, right=bar_index, bgcolor=bearishOBColour, border_color=color.new(color.red, 100))
        array.push(shortBoxes, newBox)
        label.new(bar_index, lastHigh, 'OB-', style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny, textalign=text.align_center)
        lastShortIndex := lastUpIndex

// Bullish break of structure
if showOB and showOBOnCurrentTF and array.size(shortBoxes) > 0
    for i = (array.size(shortBoxes) - 1) to 0
        sbox = array.get(shortBoxes, i)
        lstart = array.get(shortBoxStart, i)
        lstate = array.get(shortBoxState, i)
        top = box.get_top(sbox)
        left = box.get_left(sbox)
        bottom = box.get_bottom(sbox)
        if (high > bottom and low < bottom and bar_index > lstart and lstate == 0 and useMitigatedBlocks)
            sbox.set_bgcolor(mitigatedOBColour)
            array.set(shortBoxState, i, 1)
        if close > top
            box.delete(sbox)
            array.remove(shortBoxState, i)
            array.remove(shortBoxes, i)
            array.remove(shortBoxStart, i)
            if (bar_index - lastDownIndex) < 1000 and bar_index > lastLongIndex
                array.push(longBoxStart, bar_index + 1)
                array.push(longBoxState, 0)
                newBox = box.new(left=lastDownIndex, top=lastDown, bottom=lastLow, right=bar_index, bgcolor=bullishOBColour, border_color=color.new(color.green, 100))
                array.push(longBoxes, newBox)
                label.new(bar_index, lastLow, 'OB+', style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny, textalign=text.align_center)
                lastLongIndex := bar_index

// Update bullish order blocks
if showOB and showOBOnCurrentTF and array.size(longBoxes) > 0
    for i = (array.size(longBoxes) - 1) to 0
        lbox = array.get(longBoxes, i)
        lstart = array.get(longBoxStart, i)
        lstate = array.get(longBoxState, i)
        bottom = box.get_bottom(lbox)
        top = box.get_top(lbox)
        if (low <= top and high > top and bar_index > lstart and lstate == 0)
            if useMitigatedBlocks
                lbox.set_bgcolor(mitigatedOBColour)
            array.set(longBoxState, i, 1)
        if close < bottom
            array.remove(longBoxStart, i)
            array.remove(longBoxState, i)
            array.remove(longBoxes, i)
            box.delete(lbox)

// Record last up and down candles for OB
if close < open
    lastDown := high
    lastDownIndex := bar_index
    lastLow := low

if close > open
    lastUp := close
    lastUpIndex := bar_index
    lastUpLow := low
    lastHigh := high

lastHigh := high > lastHigh ? high : lastHigh
lastLow := low < lastLow ? low : lastLow

// ===================== BREAKER BLOCKS =====================
var GROUP_BB = 'Breaker Blocks'
bbTimeframe = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_BB)
bullishBBColour = input.color(color.new(#2196F3, 70), title='Bullish BB', group=GROUP_BB)
bearishBBColour = input.color(color.new(#FF9800, 70), title='Bearish BB', group=GROUP_BB)

// Determine if BB should display
bbTF = bbTimeframe == '' ? getCurrentTF() : bbTimeframe
showBBOnCurrentTF = shouldShowOnCurrentTF(bbTF)

// BB Variables
var breakerBoxes = array.new_box()
var breakerTypes = array.new_int()  // 1 = bullish, -1 = bearish
var breakerStarts = array.new_int()

// Detect Breaker Blocks (OB that got broken becomes BB)
// Bullish Breaker: Former bearish OB that price broke above
if showBB and showBBOnCurrentTF and array.size(shortBoxes) > 0
    for i = (array.size(shortBoxes) - 1) to 0
        sbox = array.get(shortBoxes, i)
        top = box.get_top(sbox)
        bottom = box.get_bottom(sbox)
        boxLeft = box.get_left(sbox)

        // If price closes above former bearish OB, it becomes a bullish breaker
        if close > top and bar_index > boxLeft + 2
            // Create breaker block
            newBB = box.new(left=boxLeft, top=top, bottom=bottom, right=bar_index, bgcolor=bullishBBColour, border_color=color.new(#2196F3, 100))
            array.push(breakerBoxes, newBB)
            array.push(breakerTypes, 1)
            array.push(breakerStarts, bar_index)
            label.new(bar_index, top, 'BB+', style=label.style_label_down, color=color.new(color.white, 100), textcolor=#2196F3, size=size.tiny)

// Bearish Breaker: Former bullish OB that price broke below
if showBB and showBBOnCurrentTF and array.size(longBoxes) > 0
    for i = (array.size(longBoxes) - 1) to 0
        lbox = array.get(longBoxes, i)
        top = box.get_top(lbox)
        bottom = box.get_bottom(lbox)
        boxLeft = box.get_left(lbox)

        // If price closes below former bullish OB, it becomes a bearish breaker
        if close < bottom and bar_index > boxLeft + 2
            // Create breaker block
            newBB = box.new(left=boxLeft, top=top, bottom=bottom, right=bar_index, bgcolor=bearishBBColour, border_color=color.new(#FF9800, 100))
            array.push(breakerBoxes, newBB)
            array.push(breakerTypes, -1)
            array.push(breakerStarts, bar_index)
            label.new(bar_index, bottom, 'BB-', style=label.style_label_up, color=color.new(color.white, 100), textcolor=#FF9800, size=size.tiny)

// Update and remove invalidated breaker blocks
if showBB and showBBOnCurrentTF and array.size(breakerBoxes) > 0
    for i = (array.size(breakerBoxes) - 1) to 0
        bbox = array.get(breakerBoxes, i)
        btype = array.get(breakerTypes, i)
        top = box.get_top(bbox)
        bottom = box.get_bottom(bbox)

        // Bullish breaker invalidated if price closes below it
        if btype == 1 and close < bottom
            box.delete(bbox)
            array.remove(breakerBoxes, i)
            array.remove(breakerTypes, i)
            array.remove(breakerStarts, i)
        // Bearish breaker invalidated if price closes above it
        else if btype == -1 and close > top
            box.delete(bbox)
            array.remove(breakerBoxes, i)
            array.remove(breakerTypes, i)
            array.remove(breakerStarts, i)

// ===================== FVG (Fair Value Gaps) =====================
var GROUP_FVG = 'Fair Value Gaps'
fvgTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_FVG)
fvgValidityPeriod = input.int(500, 'FVG Validity Period (Bars)', group=GROUP_FVG, maxval=4998, minval=10)
fvgColor = input.color(color.new(#00BFFF, 80), 'FVG Color (Light Blue)', group=GROUP_FVG)

// Determine if FVG should display
fvgTF = fvgTimeframe == '' ? getCurrentTF() : fvgTimeframe
showFVGOnCurrentTF = shouldShowOnCurrentTF(fvgTF)

// FVG Detection
bullishFVG = close > open and close[1] > open[1] and high[2] < low[0]
bearishFVG = close < open and close[1] < open[1] and low[2] > high[0]

var array<box> fvgBoxes = array.new_box()
var array<int> fvgBars = array.new_int()

// Create FVG boxes - NO labels, borders, middle lines, or text - just clean filled boxes
if showFVG and showFVGOnCurrentTF and bullishFVG
    fvgBoxes.push(box.new(bar_index[2], low[0], bar_index, high[2], bgcolor=fvgColor, border_color=color.new(#00BFFF, 100)))
    fvgBars.push(bar_index)

if showFVG and showFVGOnCurrentTF and bearishFVG
    fvgBoxes.push(box.new(bar_index[2], low[2], bar_index, high[0], bgcolor=fvgColor, border_color=color.new(#00BFFF, 100)))
    fvgBars.push(bar_index)

// Remove old FVG boxes
if fvgBoxes.size() > 0
    for i = fvgBoxes.size() - 1 to 0
        fvgBox = fvgBoxes.get(i)
        fvgTop = box.get_top(fvgBox)
        fvgBot = box.get_bottom(fvgBox)
        if bar_index - fvgBars.get(i) > fvgValidityPeriod or (low <= fvgTop and high >= fvgBot)
            box.delete(fvgBox)
            fvgBoxes.remove(i)
            fvgBars.remove(i)

// ===================== MSS & BOS =====================
var GROUP_MSS = 'Market Structure (MSS/BOS)'
tfStructure = input.timeframe('240', 'Timeframe for Analysis (4H recommended)', group=GROUP_MSS)
rlBars = input.int(2, 'Swing Bars', 1, group=GROUP_MSS)
showBos = input.bool(true, 'Show BOS', group=GROUP_MSS)
showMss = input.bool(true, 'Show MSS', group=GROUP_MSS)
mssLineColor = input.color(color.new(#404040, 0), 'MSS/BOS Line Color (Dark Gray)', group=GROUP_MSS)

// Determine if MSS/BOS should display
mssTF = tfStructure == '' ? getCurrentTF() : tfStructure
showMSSOnCurrentTF = shouldShowOnCurrentTF(mssTF)

type piv
    float pp
    int pi

var piv pH = na
var piv pL = na
var piv nPh = na
var piv nPl = na
var float nPh1 = na
var float nPl1 = na
var array<line> structLines = array.new_line()
var bool bull = false

Fmtf() =>
    phPs = ta.pivothigh(rlBars, rlBars)
    plPs = ta.pivotlow(rlBars, rlBars)
    int phBi = na
    int plBi = na
    if not na(phPs)
        phBi := time[rlBars]
    if not na(plPs)
        plBi := time[rlBars]
    [phPs, phBi, plPs, plBi]

[phPs, phBi, plPs, plBi] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, Fmtf(), lookahead=barmerge.lookahead_on)

if showMSS_BOS and showMSSOnCurrentTF and not na(phPs)
    nPh := piv.new(phPs, phBi)
    if na(pH)
        pH := piv.new(phPs, phBi)

if showMSS_BOS and showMSSOnCurrentTF and not na(plPs)
    nPl := piv.new(plPs, plBi)
    if na(pL)
        pL := piv.new(plPs, plBi)

var mssBullVar = false
var mssBearVar = false

[htfClose, htfTime] = request.security(syminfo.tickerid, tfStructure == '' ? timeframe.period : tfStructure, [close[1], time[1]], lookahead=barmerge.lookahead_on)
highCond = bull ? high : htfClose
timeHighCond = bull ? time : htfTime

if showMSS_BOS and showMSSOnCurrentTF and (plPs > nPl1 and bull) or na(nPl1) or plPs < nPl1
    nPl1 := plPs

breakHighCond = not na(pH) and highCond > pH.pp

FtfLimit(val) =>
    timeframe.in_seconds() <= timeframe.in_seconds(val == '' ? timeframe.period : val)

var tfL0 = FtfLimit(tfStructure)

if showMSS_BOS and showMSSOnCurrentTF and breakHighCond
    linCon = bull ? showBos : showMss
    isBOS = bull
    if bull
        mssBullVar := false
    else
        mssBullVar := true
    if tfL0 and linCon
        newLine = line.new(pH.pi, pH.pp, timeHighCond, pH.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pH.pi + timeHighCond) / 2)
        label.new(midX, pH.pp, labelText, xloc=xloc.bar_time, style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny, textalign=text.align_center)
    bull := true
    mssBearVar := false
    pH := na
    pL := na
    if not na(nPl1) and not na(nPl)
        pL := piv.new(nPl.pp, nPl.pi)

lowCond = bull ? htfClose : low
timeLowCond = bull ? htfTime : time

if showMSS_BOS and showMSSOnCurrentTF and (phPs < nPh1 and not bull) or na(nPh1) or phPs > nPh1
    nPh1 := phPs

breakLowCond = not na(pL) and lowCond < pL.pp

if showMSS_BOS and showMSSOnCurrentTF and breakLowCond
    linCon = bull ? showMss : showBos
    isBOS = not bull
    if not bull
        mssBearVar := false
    else
        mssBearVar := true
    if tfL0 and linCon
        newLine = line.new(pL.pi, pL.pp, timeLowCond, pL.pp, color=mssLineColor, xloc=xloc.bar_time, style=line.style_solid, width=2)
        structLines.push(newLine)
        labelText = isBOS ? 'BOS' : 'MSS'
        midX = int((pL.pi + timeLowCond) / 2)
        label.new(midX, pL.pp, labelText, xloc=xloc.bar_time, style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny, textalign=text.align_center)
    bull := false
    mssBullVar := false
    pH := na
    pL := na
    if not na(nPh1) and not na(nPh)
        pH := piv.new(nPh.pp, nPh.pi)

// ===================== DISPLACEMENT =====================
var GROUP_DISP = 'Displacement'
dispTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_DISP)
require_fvg_disp = input.bool(false, 'Require FVG', group=GROUP_DISP)
disp_type = input.string('Open to Close', 'Displacement Type', options=['Open to Close', 'High to Low'], group=GROUP_DISP)
std_len = input.int(100, minval=1, title='Displacement Length', group=GROUP_DISP)
std_x = input.int(4, minval=0, title='Displacement Strength', group=GROUP_DISP)
disp_color = input.color(color.yellow, 'Bar Color', group=GROUP_DISP)

// Determine if Displacement should display
dispTF = dispTimeframe == '' ? getCurrentTF() : dispTimeframe
showDispOnCurrentTF = shouldShowOnCurrentTF(dispTF)

candle_range = disp_type == 'Open to Close' ? math.abs(open - close) : high - low
std = ta.stdev(candle_range, std_len) * std_x
fvg_disp = close[1] > open[1] ? high[2] < low[0] : low[2] > high[0]
displacement = require_fvg_disp ? candle_range[1] > std[1] and fvg_disp : candle_range > std

barcolor(showDisplacement and showDispOnCurrentTF and displacement ? disp_color : na, offset=require_fvg_disp ? -1 : na)

// ===================== MITIGATION BLOCKS =====================
var GROUP_MB = 'Mitigation Blocks'
mbTimeframe = input.timeframe('60', 'Timeframe for Analysis (1H recommended)', group=GROUP_MB)
mbShowBull = input.bool(true, 'Show Bullish MB', group=GROUP_MB)
mbShowBear = input.bool(true, 'Show Bearish MB', group=GROUP_MB)
mbBullColor = input.color(color.new(color.green, 85), 'Bullish MB', group=GROUP_MB)
mbBearColor = input.color(color.new(color.red, 85), 'Bearish MB', group=GROUP_MB)
mbLookback = input.int(20, 'Lookback Period', group=GROUP_MB)

// Determine if MB should display
mbTF = mbTimeframe == '' ? getCurrentTF() : mbTimeframe
showMBOnCurrentTF = shouldShowOnCurrentTF(mbTF)

var array<box> mbBullBoxes = array.new_box()
var array<box> mbBearBoxes = array.new_box()

// Detect mitigation blocks
if showMB and showMBOnCurrentTF and mbShowBull
    bullishMB = close[1] > open[1] and low <= low[1] and close > low[1]
    if bullishMB
        mbBullBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBullColor, border_color=color.new(color.green, 100)))
        label.new(bar_index, low[1], 'MB+', style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny)

if showMB and showMBOnCurrentTF and mbShowBear
    bearishMB = close[1] < open[1] and high >= high[1] and close < high[1]
    if bearishMB
        mbBearBoxes.push(box.new(bar_index[1], high[1], bar_index, low[1], bgcolor=mbBearColor, border_color=color.new(color.red, 100)))
        label.new(bar_index, high[1], 'MB-', style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny)

// Remove old MB boxes
if mbBullBoxes.size() > mbLookback
    box.delete(mbBullBoxes.shift())

if mbBearBoxes.size() > mbLookback
    box.delete(mbBearBoxes.shift())
