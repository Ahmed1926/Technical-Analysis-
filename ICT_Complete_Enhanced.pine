// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo
// Enhanced by Claude - Integrated Breaker Blocks, Propulsion Blocks, Mitigation Blocks, and Trading Sessions

//@version=5
indicator("ICT Complete Enhanced [LuxAlgo + Sessions]", max_lines_count=500, max_boxes_count=500, max_labels_count=500, max_bars_back=3000, overlay=true)

//-----------------------------------------------------------------------------}
//Strings
//-----------------------------------------------------------------------------{
o          = 'Options'
sp1        = '       '
sp2        = '              '
hl         = 'High / Low    ' + sp1

//-----------------------------------------------------------------------------}
//Global Settings
//-----------------------------------------------------------------------------{
i_mode     = input.string(         'Present'      , title = 'Mode'                   , options =['Present', 'Historical']                                              )

//-----------------------------------------------------------------------------}
//Market Structure Shift Settings
//-----------------------------------------------------------------------------{
showMS     = input.bool  (           true         , title = ''                       ,   group = 'Market Structures', inline = 'MS'                                    )
len        = input.int   (            10          , title = '     Length   ' +sp2    ,   group = 'Market Structures', inline = 'MS'       , minval = 3, maxval =  10   )

iMSS       = input.bool  (           true         , title = '       MSS'     +sp1    ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'M1'                                    )
cMSSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'M1'                                    )

iBOS       = input.bool  (           true         , title = '       BOS'     +sp1    ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbl     = input.color (color.new(#00e6a1,  0), title = 'bullish'                ,   group = 'Market Structures', inline = 'BS'                                    )
cBOSbr     = input.color (color.new(#e60400,  0), title = 'bearish'                ,   group = 'Market Structures', inline = 'BS'                                    )

//-----------------------------------------------------------------------------}
//Displacement Settings
//-----------------------------------------------------------------------------{
sDispl     = input.bool  (           true         , title = 'Show Displacement'      ,   group = 'Displacement'                                                        )
perc_Body  = 0.36
bxBack     = 10

//-----------------------------------------------------------------------------}
//Volume Imbalance Settings
//-----------------------------------------------------------------------------{
sVimbl     = input.bool  (           true         , title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )
visVim     = input.int   (             5          , title = "   # Visible VI's  "+sp1,   group = 'Volume Imbalance' , inline = 'VI'      , minval = 2, maxval = 100    )
cVimbl     = input.color (color.new(#06b2d0,  0), title = ''                       ,   group = 'Volume Imbalance' , inline = 'VI'                                    )

//-----------------------------------------------------------------------------}
//Order Blocks Settings
//-----------------------------------------------------------------------------{
showOB     = input.bool  (           true         , title = 'Show Order Blocks'      ,   group = 'Order Blocks'                                                        )
length     = input.int   (            10          , title = 'Swing Lookback'         ,   group = 'Order Blocks'                          , minval = 3                  )
showBull   = input.int   (             5          , title = 'Show Last Bullish OB'   ,   group = 'Order Blocks'                          , minval = 0                  )
showBear   = input.int   (             5          , title = 'Show Last Bearish OB'   ,   group = 'Order Blocks'                          , minval = 0                  )
useBody    = input.bool  (           true         , title = 'Use Candle Body'        ,   group = 'Order Blocks'                                                        )

bullCss    = input.color (color.new(#3e89fa, 10), title = 'Bullish OB  '           ,   group = 'Order Blocks'     , inline = 'bullcss'                               )
bullBrkCss = input.color (color.new(#4785f9, 85), title = 'Bullish Break  '        ,   group = 'Order Blocks'     , inline = 'bullcss'                               )
bearCss    = input.color (color.new(#FF3131, 10), title = 'Bearish OB'             ,   group = 'Order Blocks'     , inline = 'bearcss'                               )
bearBrkCss = input.color (color.new(#f9ff57, 85), title = 'Bearish Break'          ,   group = 'Order Blocks'     , inline = 'bearcss'                               )
showLabels = input.bool  (          false, title = 'Show Historical Polarity Changes',   group = 'Order Blocks'                                                        )

//-----------------------------------------------------------------------------}
//Breaker Blocks Settings (LuxAlgo)
//-----------------------------------------------------------------------------{
showBB           = input.bool  (  true    , title = 'Show Breaker Blocks'            ,   group = 'Breaker Blocks'                                  )
breakerShowBoxes = input.bool  (  true    , title = 'Show as Boxes'                  ,   group = 'Breaker Blocks'                                  )
bbMaxCount       = input.int   (      3   , title = 'Max Breaker Blocks'             ,   group = 'Breaker Blocks', minval = 1, maxval = 50          )
cBBplusA         = input.color (color.new(#0cc11a, 90), title = 'Bullish BB'        ,   group = 'Breaker Blocks', inline = 'bb1'                   )
cBB_minA         = input.color (color.new(#ff1100, 90), title = 'Bearish BB'        ,   group = 'Breaker Blocks', inline = 'bb1'                   )

//-----------------------------------------------------------------------------}
//Propulsion Blocks Settings (LuxAlgo)
//-----------------------------------------------------------------------------{
showPB       = input.bool  (  true  , title = 'Show Propulsion Blocks'                 ,   group = 'Propulsion Blocks'                                )
pbShowMean   = input.bool  (  false , title = 'Show Mean Line'                         ,   group = 'Propulsion Blocks'                                )
pbMaxCount   = input.int   (     3  , title = 'Max Propulsion Blocks'                  ,   group = 'Propulsion Blocks', minval = 1, maxval = 50       )
pbSwingLen   = input.int   (     3  , title = 'Swing Detection Length'                 ,   group = 'Propulsion Blocks', minval = 1                    )
cPBplus      = input.color (color.new(#089981, 90), title = 'Bullish PB'              ,   group = 'Propulsion Blocks', inline = 'pb1'                )
cPBminus     = input.color (color.new(#F23645, 90), title = 'Bearish PB'              ,   group = 'Propulsion Blocks', inline = 'pb1'                )

//-----------------------------------------------------------------------------}
//Mitigation Blocks Settings
//-----------------------------------------------------------------------------{
showMB      = input.bool  (  true  , title = 'Show Mitigation Blocks'                  ,   group = 'Mitigation Blocks'                                )
mbShowBull  = input.bool  (  true  , title = 'Show Bullish MB'                         ,   group = 'Mitigation Blocks'                                )
mbShowBear  = input.bool  (  true  , title = 'Show Bearish MB'                         ,   group = 'Mitigation Blocks'                                )
mbBullColor = input.color (color.new(color.green, 90), title = 'Bullish MB'          ,   group = 'Mitigation Blocks', inline = 'mb1'                )
mbBearColor = input.color (color.new(color.red, 90), title = 'Bearish MB'            ,   group = 'Mitigation Blocks', inline = 'mb1'                )
mbLookback  = input.int   (     3  , title = 'Max Visible MBs'                         ,   group = 'Mitigation Blocks'                                )

//-----------------------------------------------------------------------------}
//Liquidity Settings
//-----------------------------------------------------------------------------{
showLq     = input.bool  (           true         , title = 'Show Liquidity'         ,   group = 'Liquidity'                                                           )
a     = 10 / input.float (             4          , title = 'margin'                 ,   group = 'Liquidity'   , step = 0.1, minval = 2, maxval =   7                  )
visLiq     = input.int   (             2          , title = '# Visible Liq. boxes'   ,   group = 'Liquidity'
           ,                                       minval = 1         , maxval = 50  , tooltip = 'In the same direction'                                               )
cLIQ_B     = input.color (color.new(#fa451c,  0), title = 'Buyside Liquidity  '    ,   group = 'Liquidity'                                                           )
cLIQ_S     = input.color (color.new(#1ce4fa,  0), title = 'Sellside Liquidity'     ,   group = 'Liquidity'                                                           )

//-----------------------------------------------------------------------------}
//FVG Settings
//-----------------------------------------------------------------------------{
shwFVG     = input.bool  (           true         , title = 'Show FVGs'              ,   group = 'Fair Value Gaps'                                                     )
i_BPR      = input.bool  (           false        , title = 'Balance Price Range'    ,   group = 'Fair Value Gaps'                                                     )
i_FVG      = input.string(           'FVG'        , title = o                        ,   group = 'Fair Value Gaps'  , options=['FVG', 'IFVG']
           ,                                                                           tooltip = 'Fair Value Gaps\nor\nImplied Fair Value Gaps'                        )
visBxs     = input.int   (             5          , title = '# Visible FVG\'s'       ,   group = 'Fair Value Gaps'
           ,                                       minval = 1         , maxval = 20  , tooltip = 'In the same direction'                                               )

cFVGbl     = input.color (color.new(#00e676, 10), title = 'Bullish FVG  '          ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGblBR   = input.color (color.new(#808000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbl'                                 )
cFVGbr     = input.color (color.new(#ff5252, 10), title = 'Bearish FVG '           ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )
cFVGbrBR   = input.color (color.new(#FF0000,  0), title = 'Break'                  ,   group = 'Fair Value Gaps'  , inline = 'FVGbr'                                 )

//-----------------------------------------------------------------------------}
//NWOG/NDOG Settings
//-----------------------------------------------------------------------------{
iNWOG      = input.bool  (           true         , title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG1     = input.color (color.new(#ff5252, 28), title = 'NWOG    ', inline='NWOG',   group = 'NWOG/NDOG'                                                           )
cNWOG2     = input.color (color.new(#b2b5be, 50), title = ''        , inline='NWOG',   group = 'NWOG/NDOG'                                                           )
maxNWOG    = input.int   (             3          , title = 'Show max', inline='NWOG',   group = 'NWOG/NDOG'                , minval = 0, maxval =  50                 )

iNDOG      = input.bool  (           true         , title = ''        , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG1     = input.color (color.new(#ff9800, 20), title = 'NDOG    ', inline='NDOG',   group = 'NWOG/NDOG'                                                           )
cNDOG2     = input.color (color.new(#4dd0e1, 65), title =    ''     , inline='NDOG',   group = 'NWOG/NDOG'                                                           )
maxNDOG    = input.int   (             1          , title = 'Show max', inline='NDOG',   group = 'NWOG/NDOG'                , minval = 0, maxval =  50                 )

//-----------------------------------------------------------------------------}
//Fibonacci Settings
//-----------------------------------------------------------------------------{
iFib       = input.string(           'NONE'      , title = 'Fibonacci between last: ',   group = 'Fibonacci', options=['FVG', 'BPR', 'OB', 'Liq', 'VI', 'NWOG', 'NONE'])
iExt       = input.bool  (           true        , title = 'Extend lines'            ,   group = 'Fibonacci'                                                           )

//-----------------------------------------------------------------------------}
//Trading Sessions Settings (Comprehensive)
//-----------------------------------------------------------------------------{
// Asian Session Inputs
showAsian               = input.bool(true, 'Show Asian Session', group='Trading Sessions')
user_ssth               = input.string("20", title="Asian Start Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
user_sstm               = input.string("00", title="Asian Start Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
user_esth               = input.string("02", title="Asian End Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
user_estm               = input.string("00", title="Asian End Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
user_box_line_color     = input.string("orange", title="Asian Range Border Color", group='Trading Sessions', options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
boxLineWidth            = input.int(1, title="Asian Box Line Width", group='Trading Sessions', minval=0, maxval=10)
sessionLineWidth        = input.int(2, title="Asian Session Line Width", group='Trading Sessions', minval=0, maxval=20)

// London Session Inputs
showLondon              = input.bool(true, 'Show London Session', group='Trading Sessions')
show_london_session_rng = input.bool(true, title="Show London Session Range Pips", group='Trading Sessions')
london_ssth             = input.string("03", title="London Start Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
london_sstm             = input.string("00", title="London Start Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
london_esth             = input.string("07", title="London End Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
london_estm             = input.string("00", title="London End Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
luser_box_line_color    = input.string("blue", title="London Range Border Color", group='Trading Sessions', options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
lboxLineWidth           = input.int(1, title="London Box Line Width", group='Trading Sessions', minval=0, maxval=10)
lsessionLineWidth       = input.int(2, title="London Session Line Width", group='Trading Sessions', minval=0, maxval=20)

// New York Session Inputs
showNY                  = input.bool(true, 'Show New York Session', group='Trading Sessions')
show_ny_session_rng     = input.bool(true, title="Show New York Session Range Pips", group='Trading Sessions')
ny_ssth                 = input.string("08", title="New York Start Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
ny_sstm                 = input.string("00", title="New York Start Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
ny_esth                 = input.string("12", title="New York End Hour (EST)", group='Trading Sessions', options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])
ny_estm                 = input.string("00", title="New York End Minute (EST)", group='Trading Sessions', options=["00", "15", "30", "45"])
nuser_box_line_color    = input.string("black", title="New York Range Border Color", group='Trading Sessions', options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
nboxLineWidth           = input.int(1, title="New York Box Line Width", group='Trading Sessions', minval=0, maxval=10)
nsessionLineWidth       = input.int(2, title="New York Session Line Width", group='Trading Sessions', minval=0, maxval=20)

// Previous Day/Week Levels
showPreviousDayHiLo     = input.bool(true, title="Show Previous Days High / Low", group='Trading Sessions')
previousDayHiLoColor    = input.string("yellow", title="Previous Days Line Color", group='Trading Sessions', options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
supportLineWidth        = input.int(10, title="Previous Days Line Width", group='Trading Sessions', minval=0, maxval=20)

showLastWeeklyHiLo      = input.bool(true, title="Show Last Weeks High / Low", group='Trading Sessions')
lastWeeklyHiLoColor     = input.string("orange", title="Last Week Line Color", group='Trading Sessions', options=["aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "orange", "purple", "red", "silver", "teal", "white", "yellow"])
supportLastWeekLineWidth= input.int(10, title="Last Week Line Width", group='Trading Sessions', minval=0, maxval=20)

// ADR
showADR                 = input.bool(false, title="Show Average Daily Range", group='Trading Sessions')
is_forex_pips           = input.bool(false, title="Display average range as forex pips?", group='Trading Sessions')
daily_adr_user          = input.int(1, title="Show ADR for x days", group='Trading Sessions', minval=0)
daily_adr_length        = input.int(21, title="ADR Length parameter (Days - default 3 weeks, 21 days)", group='Trading Sessions', minval=0)

//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
n          =                      bar_index
hi         =                      high
lo         =                      low
tf_msec    = timeframe.in_seconds(timeframe.period) * 1000
maxSize    =        50
atr        = ta.atr(10)
per        = i_mode == 'Present' ? last_bar_index - bar_index <=  500 : true
perB       = last_bar_index - bar_index <= 1000  ? true : false
xloc       = iFib   ==   'OB'    ? xloc.bar_time : xloc.bar_index
ext        = iExt                ?  extend.right : extend.none
plus       = iFib   ==   'OB'    ?  tf_msec * 50 : 50
mx         = math.max(close , open)
mn         = math.min(close , open)
body       = math.abs(close - open)
meanBody   = ta.sma  (body  ,  len)
max        = useBody ?  mx  : high
min        = useBody ?  mn  : low
blBrkConf  = 0
brBrkConf  = 0
r          = color.r(chart.bg_color)
g          = color.g(chart.bg_color)
b          = color.b(chart.bg_color)
isDark     = r < 80 and g < 80 and b < 80

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ
    int   [] d
    int   [] x
    float [] y
    bool  [] b

type ln_d
    line  l
    int   d

type _2ln_lb
    line  l1
    line  l2
    label lb

type bx_ln
    box   b
    line  l

type bx_ln_lb
    box   bx
    line  ln
    label lb

type mss
    int     dir
    line [] l_mssBl
    line [] l_mssBr
    line [] l_bosBl
    line [] l_bosBr
    label[] lbMssBl
    label[] lbMssBr
    label[] lbBosBl
    label[] lbBosBr

type liq
    box   bx
    bool  broken
    bool  brokenTop
    bool  brokenBtm
    line  ln

type ob
    float   top       = na
    float   btm       = na
    int     loc       = bar_index
    bool    breaker   = false
    int     break_loc = na

type swing
    float y = na
    int   x = na
    bool  crossed = false

type FVG
    box box
    bool active
    int  pos

// Breaker Block Type
type breaker
    float top
    float btm
    float center
    int   start
    box   bx
    line  ln
    label lb
    bool  mitigated
    int   direction

// Propulsion Block Type
type propulsion
    float price
    float mean
    int   start
    line  pline
    line  mline
    label lb
    int   direction

// Mitigation Block Type
type mitblock
    float top
    float btm
    int   start
    box   bx
    label lb

var mss MSS = mss.new(
 0
 , array.new < line  >()
 , array.new < line  >()
 , array.new < line  >()
 , array.new < line  >()
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 )

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
maxVimb = 2

var float friCp = na, var int friCi = na
var float monOp = na, var int monOi = na
var float prDCp = na, var int prDCi = na
var float cuDOp = na, var int cuDOi = na

var _2ln_lb [] Vimbal     = array.new<  _2ln_lb >()
var   liq   [] b_liq_B    = array.new<    liq   >(1, liq.new(box(na), false, false, false, line(na)))
var   liq   [] b_liq_S    = array.new<    liq   >(1, liq.new(box(na), false, false, false, line(na)))
var    ob   [] bullish_ob = array.new<    ob    >()
var    ob   [] bearish_ob = array.new<    ob    >()
var bx_ln   [] bl_NWOG    = array.new<   bx_ln  >()
var bx_ln   [] bl_NDOG    = array.new<   bx_ln  >()
var bx_ln_lb[] a_bx_ln_lb = array.new< bx_ln_lb >()
var FVG     [] bFVG_UP    = array.new<    FVG   >()
var FVG     [] bFVG_DN    = array.new<    FVG   >()
var FVG     [] bBPR_UP    = array.new<    FVG   >()
var FVG     [] bBPR_DN    = array.new<    FVG   >()

// Breaker Blocks Arrays
var breaker[] a_breaker_bull = array.new<breaker>()
var breaker[] a_breaker_bear = array.new<breaker>()

// Propulsion Blocks Arrays
var propulsion[] a_propulsion_bull = array.new<propulsion>()
var propulsion[] a_propulsion_bear = array.new<propulsion>()

// Mitigation Blocks Arrays
var mitblock[] a_mitblock_bull = array.new<mitblock>()
var mitblock[] a_mitblock_bear = array.new<mitblock>()

var  ZZ         aZZ       =
 ZZ.new(
 array.new < int    >(maxSize,  0),
 array.new < int    >(maxSize,  0),
 array.new < float  >(maxSize, na),
 array.new < bool   >(maxSize, na))

var line _diag = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dashed, xloc= xloc            )
var line _vert = line.new(na, na, na, na, color=color.new(color.silver, 50), style=line.style_dotted, xloc= xloc            )
var line _zero = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _0236 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0382 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0500 = line.new(na, na, na, na, color=color.new(color.green , 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _0786 = line.new(na, na, na, na, color=color.new(color.orange, 25), style=line.style_solid , xloc= xloc, extend=ext)
var line _one_ = line.new(na, na, na, na, color=color.new(color.silver,  5), style=line.style_solid , xloc= xloc, extend=ext)
var line _1618 = line.new(na, na, na, na, color=color.new(color.yellow, 25), style=line.style_solid , xloc= xloc, extend=ext)

//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
method in_out(ZZ aZZ, int d, int x1, float y1, int x2, float y2, color col, bool b) =>
    aZZ.d.unshift(d), aZZ.x.unshift(x2), aZZ.y.unshift(y2), aZZ.b.unshift(b), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop(), aZZ.b.pop()

method timeinrange(string res, string sess) => not na(time(timeframe.period, res, sess))

method setLine(line ln, int x1, float y1, int x2, float y2) => ln.set_xy1(x1, y1), ln.set_xy2(x2, y2)

time_to_bar_index(t) =>
    var int result = 0
    if not na(t)
        result := bar_index - ta.barssince(time == t)
    result

method clear_aLine(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(label[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method clear_aLabLin(line[] l) =>
    if l.size() > 0
        for i = l.size() -1 to 0
            l.pop().delete()

method notransp(color css) => color.rgb(color.r(css), color.g(css), color.b(css))

method display(ob id, css, break_css, str)=>
    if showOB
        if id.breaker
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               box.new(id.loc, id.top, timenow + (tf_msec * 50), id.btm, na
             , bgcolor = break_css
             , extend  = extend.none
             , xloc    = xloc.bar_time)
             , line (na)
             , label(na))
             )
        else
            y  = str == 'bl' ? id.btm : id.top
            s  = str == 'bl' ? label.style_label_up : label.style_label_down
            a_bx_ln_lb.unshift(
             bx_ln_lb.new(
               box(na)
             , line.new(id.loc,   y  , id.loc  + (tf_msec * 50),    y
             , xloc    = xloc.bar_time, color=css, width=2, extend=extend.right)
             , label.new(              id.loc  + (tf_msec * 50),    y
             , text  = str == 'bl' ? '+OB' : 'OB-'
             , xloc  = xloc.bar_time
             , style = s    , color = color(na)
             , textcolor=css, size  = size.small))
             )

swings(len)=>
    var os = 0
    var swing top = swing.new(na, na)
    var swing btm = swing.new(na, na)

    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0
       :  low [len] < lower ? 1 : os

    if os == 0 and os[1] != 0
        top := swing.new(high[length], bar_index[length])

    if os == 1 and os[1] != 1
        btm := swing.new(low[length], bar_index[length])

    [top, btm]

set_lab(i, str) =>
    style = str == 'Bl' ? label.style_label_down : label.style_label_up
    txcol = str == 'Bl' ? color.lime : color.red
    label.new(math.round(math.avg(aZZ.x.get(i), n)), aZZ.y.get(i), text='BOS'
     , style=style, color=color(na), textcolor=txcol, size=size.tiny)

set_lin(i, str) =>
    color = str == 'Bl' ? color.lime : color.red
    line.new(aZZ.x.get(i), aZZ.y.get(i), n, aZZ.y.get(i), color=color, style=line.style_solid)

draw(left, col) =>
    //
    max_bars_back(time, 1000)
    var int dir= na, var int x1= na, var float y1= na, var int x2= na, var float y2= na
    //
    sz       = aZZ.d.size( )
    x2      := bar_index -1
    ph       = ta.pivothigh(hi, left, 1)
    pl       = ta.pivotlow (lo, left, 1)
    if ph
        dir := aZZ.d.get (0)
        x1  := aZZ.x.get (0)
        y1  := aZZ.y.get (0)
        y2  :=      nz(hi[1])
        //
        if dir <  1
            aZZ.in_out( 1, x1, y1, x2, y2, col, true)
        else
            if dir ==  1 and ph > y1
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        //
        // liquidity
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) ==  1
                    if aZZ.y.get(i) > ph + (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > ph - (atr/a) and aZZ.y.get(i) < ph + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_B.get(0)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(math.avg(minP, maxP) + (atr/a))
                    getB.bx.set_rightbottom(n +10, math.avg(minP, maxP) - (atr/a))
                else
                    b_liq_B.unshift(liq.new(
                     box.new(
                       st_B, math.avg(minP, maxP) + (atr/a), n +10, math.avg(minP, maxP) - (atr/a)
                     , text = 'Buyside liquidity', text_size = size.tiny, text_halign = text.align_left
                     , text_valign = text.align_bottom, text_color = color.new(cLIQ_B, 25)
                     , bgcolor=color(na), border_color=color(na)
                      )
                     , false
                     , false
                     , false
                     , line.new(st_B, st_P, n -1, st_P, color = color.new(cLIQ_B, 0))
                      )
                     )
                if b_liq_B.size() > visLiq
                    getLast = b_liq_B.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()
    //
    if pl
        dir := aZZ.d.get (0)
        x1  := aZZ.x.get (0)
        y1  := aZZ.y.get (0)
        y2  :=      nz(lo[1])
        //
        if dir > -1
            aZZ.in_out(-1, x1, y1, x2, y2, col, true)
        else
            if dir == -1 and pl < y1
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)
        //
        //Liquidity
        if showLq and per and sz > 0
            count = 0
            st_P  = 0.
            st_B  = 0
            minP  = 0.
            maxP  = 10e6
            for i = 0 to math.min(sz, 50) -1
                if aZZ.d.get(i) == -1
                    if aZZ.y.get(i) < pl - (atr/a)
                        break
                    else
                        if aZZ.y.get(i) > pl - (atr/a) and aZZ.y.get(i) < pl + (atr/a)
                            count += 1
                            st_B := aZZ.x.get(i)
                            st_P := aZZ.y.get(i)
                            if aZZ.y.get(i) > minP
                                minP := aZZ.y.get(i)
                            if aZZ.y.get(i) < maxP
                                maxP := aZZ.y.get(i)
            if count > 2
                getB = b_liq_S.get(0)
                if st_B == getB.bx.get_left()
                    getB.bx.set_top(math.avg(minP, maxP) + (atr/a))
                    getB.bx.set_rightbottom(n +10, math.avg(minP, maxP) - (atr/a))
                else
                    b_liq_S.unshift(liq.new(
                      box.new(
                       st_B, math.avg(minP, maxP) + (atr/a), n +10, math.avg(minP, maxP) - (atr/a)
                     , text = 'Sellside liquidity', text_size = size.tiny, text_halign = text.align_left
                     , text_valign = text.align_bottom, text_color = color.new(cLIQ_S, 25)
                     , bgcolor=color(na), border_color=color(na)
                      )
                     , false
                     , false
                     , false
                     , line.new(st_B, st_P, n -1, st_P, color = color.new(cLIQ_S, 0))
                      )
                     )
                if b_liq_S.size() > visLiq
                    getLast = b_liq_S.pop()
                    getLast.bx.delete()
                    getLast.ln.delete()
    //
    //Market Structure Shift
    if showMS
        //
        iH = aZZ.d.get(2) ==  1 ? 2 : 1
        iL = aZZ.d.get(2) == -1 ? 2 : 1
        //
        switch
            // MSS Bullish
            close > aZZ.y.get(iH) and aZZ.d.get(iH) ==  1 and MSS.dir <  1 =>
                MSS.dir :=  1
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin()
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin()
                //
                MSS.l_mssBl.unshift(line.new (
                  aZZ.x.get(iH), aZZ.y.get(iH), n, aZZ.y.get(iH), color=cMSSbl))
                MSS.lbMssBl.unshift(label.new(
                  math.round(math.avg(aZZ.x.get(iH), n)), aZZ.y.get(iH), text ='MSS'
                  , style=label.style_label_down, size=size.tiny, color=color(na), textcolor=cMSSbl))
            // MSS Bearish
            close < aZZ.y.get(iL) and aZZ.d.get(iL) == -1 and MSS.dir > -1 =>
                MSS.dir := -1
                if i_mode == 'Present'
                    MSS.l_bosBl.clear_aLabLin(), MSS.l_bosBr.clear_aLabLin()
                    MSS.lbBosBl.clear_aLabLin(), MSS.lbBosBr.clear_aLabLin()
                    MSS.l_mssBl.clear_aLabLin(), MSS.l_mssBr.clear_aLabLin()
                    MSS.lbMssBl.clear_aLabLin(), MSS.lbMssBr.clear_aLabLin()
                //
                MSS.l_mssBr.unshift(line.new (
                  aZZ.x.get(iL), aZZ.y.get(iL), n, aZZ.y.get(iL), color=cMSSbr))
                MSS.lbMssBr.unshift(label.new(
                  math.round(math.avg(aZZ.x.get(iL), n)), aZZ.y.get(iL), text ='MSS'
                  , style=label.style_label_up  , size=size.tiny, color=color(na), textcolor=cMSSbr))
            // BOS Bullish
            MSS.dir ==  1 and close > aZZ.y.get(iH) and iBOS =>
                if MSS.l_bosBl.size() > 0
                    if aZZ.y.get(iH) != MSS.l_bosBl.get(0).get_y2() and
                       aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
                else
                    if aZZ.y.get(iH) != MSS.l_mssBl.get(0).get_y2()
                        MSS.l_bosBl.unshift(set_lin(iH, 'Bl')), MSS.lbBosBl.unshift(set_lab(iH, 'Bl'))
            // BOS Bearish
            MSS.dir == -1 and close < aZZ.y.get(iL) and iBOS =>
                if MSS.l_bosBr.size() > 0
                    if aZZ.y.get(iL) != MSS.l_bosBr.get(0).get_y2() and
                       aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
                else
                    if aZZ.y.get(iL) != MSS.l_mssBr.get(0).get_y2()
                        MSS.l_bosBr.unshift(set_lin(iL, 'Br')), MSS.lbBosBr.unshift(set_lab(iL, 'Br'))
        if not iMSS
            MSS.l_mssBl.get(0).set_color(color(na)), MSS.lbMssBl.get(0).set_textcolor(color(na))
            MSS.l_mssBr.get(0).set_color(color(na)), MSS.lbMssBr.get(0).set_textcolor(color(na))

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
draw(len, color.yellow)

if MSS.l_bosBl.size() > 200
    MSS.l_bosBl.pop().delete()
    MSS.lbBosBl.pop().delete()

if MSS.l_bosBr.size() > 200
    MSS.l_bosBr.pop().delete()
    MSS.lbBosBr.pop().delete()

//-----------------------------------------------------------------------------}
// Trading Sessions - Comprehensive Implementation
//-----------------------------------------------------------------------------{
// Helper Functions
open_bar(ses) =>
    t = time("D", ses)
    na(t[1]) and not na(t) or t[1] < t

is_open(ses) =>
    not na(time(timeframe.period, ses))

// Color conversions for Asian Session
line_color = user_box_line_color == "aqua" ? color.aqua : user_box_line_color == "black" ? color.black : user_box_line_color == "blue" ? color.blue : user_box_line_color == "fuchsia" ? color.fuchsia : user_box_line_color == "gray" ? color.gray : user_box_line_color == "green" ? color.green : user_box_line_color == "lime" ? color.lime : user_box_line_color == "maroon" ? color.maroon : user_box_line_color == "navy" ? color.navy : user_box_line_color == "olive" ? color.olive : user_box_line_color == "orange" ? color.orange : user_box_line_color == "purple" ? color.purple : user_box_line_color == "red" ? color.red : user_box_line_color == "silver" ? color.silver : user_box_line_color == "teal" ? color.teal : user_box_line_color == "white" ? color.white : user_box_line_color == "yellow" ? color.yellow : color.black

// Color conversions for London Session
lline_color = luser_box_line_color == "aqua" ? color.aqua : luser_box_line_color == "black" ? color.black : luser_box_line_color == "blue" ? color.blue : luser_box_line_color == "fuchsia" ? color.fuchsia : luser_box_line_color == "gray" ? color.gray : luser_box_line_color == "green" ? color.green : luser_box_line_color == "lime" ? color.lime : luser_box_line_color == "maroon" ? color.maroon : luser_box_line_color == "navy" ? color.navy : luser_box_line_color == "olive" ? color.olive : luser_box_line_color == "orange" ? color.orange : luser_box_line_color == "purple" ? color.purple : luser_box_line_color == "red" ? color.red : luser_box_line_color == "silver" ? color.silver : luser_box_line_color == "teal" ? color.teal : luser_box_line_color == "white" ? color.white : luser_box_line_color == "yellow" ? color.yellow : color.black

// Color conversions for NY Session
nline_color = nuser_box_line_color == "aqua" ? color.aqua : nuser_box_line_color == "black" ? color.black : nuser_box_line_color == "blue" ? color.blue : nuser_box_line_color == "fuchsia" ? color.fuchsia : nuser_box_line_color == "gray" ? color.gray : nuser_box_line_color == "green" ? color.green : nuser_box_line_color == "lime" ? color.lime : nuser_box_line_color == "maroon" ? color.maroon : nuser_box_line_color == "navy" ? color.navy : nuser_box_line_color == "olive" ? color.olive : nuser_box_line_color == "orange" ? color.orange : nuser_box_line_color == "purple" ? color.purple : nuser_box_line_color == "red" ? color.red : nuser_box_line_color == "silver" ? color.silver : nuser_box_line_color == "teal" ? color.teal : nuser_box_line_color == "white" ? color.white : nuser_box_line_color == "yellow" ? color.yellow : color.black

// Support/Resistance colors
support_line_color = previousDayHiLoColor == "aqua" ? color.aqua : previousDayHiLoColor == "black" ? color.black : previousDayHiLoColor == "blue" ? color.blue : previousDayHiLoColor == "fuchsia" ? color.fuchsia : previousDayHiLoColor == "gray" ? color.gray : previousDayHiLoColor == "green" ? color.green : previousDayHiLoColor == "lime" ? color.lime : previousDayHiLoColor == "maroon" ? color.maroon : previousDayHiLoColor == "navy" ? color.navy : previousDayHiLoColor == "olive" ? color.olive : previousDayHiLoColor == "orange" ? color.orange : previousDayHiLoColor == "purple" ? color.purple : previousDayHiLoColor == "red" ? color.red : previousDayHiLoColor == "silver" ? color.silver : previousDayHiLoColor == "teal" ? color.teal : previousDayHiLoColor == "white" ? color.white : previousDayHiLoColor == "yellow" ? color.yellow : color.black

support_last_week_line_color = lastWeeklyHiLoColor == "aqua" ? color.aqua : lastWeeklyHiLoColor == "black" ? color.black : lastWeeklyHiLoColor == "blue" ? color.blue : lastWeeklyHiLoColor == "fuchsia" ? color.fuchsia : lastWeeklyHiLoColor == "gray" ? color.gray : lastWeeklyHiLoColor == "green" ? color.green : lastWeeklyHiLoColor == "lime" ? color.lime : lastWeeklyHiLoColor == "maroon" ? color.maroon : lastWeeklyHiLoColor == "navy" ? color.navy : lastWeeklyHiLoColor == "olive" ? color.olive : lastWeeklyHiLoColor == "orange" ? color.orange : lastWeeklyHiLoColor == "purple" ? color.purple : lastWeeklyHiLoColor == "red" ? color.red : lastWeeklyHiLoColor == "silver" ? color.silver : lastWeeklyHiLoColor == "teal" ? color.teal : lastWeeklyHiLoColor == "white" ? color.white : lastWeeklyHiLoColor == "yellow" ? color.yellow : color.black

// Chart time period for calculations
chart_time_period_int = timeframe.period == "1" ? 1 : timeframe.period == "3" ? 3 : timeframe.period == "5" ? 5 : timeframe.period == "15" ? 15 : timeframe.period == "30" ? 30 : timeframe.period == "45" ? 45 : 15
tickerExchangeOffset = 4

// Asian Session time conversions
int start_session_hour_int = user_ssth == "00" ? 0 : user_ssth == "01" ? 1 : user_ssth == "02" ? 2 : user_ssth == "03" ? 3 : user_ssth == "04" ? 4 : user_ssth == "05" ? 5 : user_ssth == "06" ? 6 : user_ssth == "07" ? 7 : user_ssth == "08" ? 8 : user_ssth == "09" ? 9 : user_ssth == "10" ? 10 : user_ssth == "11" ? 11 : user_ssth == "12" ? 12 : user_ssth == "13" ? 13 : user_ssth == "14" ? 14 : user_ssth == "15" ? 15 : user_ssth == "16" ? 16 : user_ssth == "17" ? 17 : user_ssth == "18" ? 18 : user_ssth == "19" ? 19 : user_ssth == "20" ? 20 : user_ssth == "21" ? 21 : user_ssth == "22" ? 22 : user_ssth == "23" ? 23 : 0
start_session_minute_int = user_sstm == "00" ? 0 : user_sstm == "15" ? 15 : user_sstm == "30" ? 30 : user_sstm == "45" ? 45 : 0

int end_session_hour_int = user_esth == "00" ? 0 : user_esth == "01" ? 1 : user_esth == "02" ? 2 : user_esth == "03" ? 3 : user_esth == "04" ? 4 : user_esth == "05" ? 5 : user_esth == "06" ? 6 : user_esth == "07" ? 7 : user_esth == "08" ? 8 : user_esth == "09" ? 9 : user_esth == "10" ? 10 : user_esth == "11" ? 11 : user_esth == "12" ? 12 : user_esth == "13" ? 13 : user_esth == "14" ? 14 : user_esth == "15" ? 15 : user_esth == "16" ? 16 : user_esth == "17" ? 17 : user_esth == "18" ? 18 : user_esth == "19" ? 19 : user_esth == "20" ? 20 : user_esth == "21" ? 21 : user_esth == "22" ? 22 : user_esth == "23" ? 23 : 0
end_session_minute_int = user_estm == "00" ? 0 : user_estm == "15" ? 15 : user_estm == "30" ? 30 : user_estm == "45" ? 45 : 0

// London Session time conversions
int london_start_session_hour_int = london_ssth == "00" ? 0 : london_ssth == "01" ? 1 : london_ssth == "02" ? 2 : london_ssth == "03" ? 3 : london_ssth == "04" ? 4 : london_ssth == "05" ? 5 : london_ssth == "06" ? 6 : london_ssth == "07" ? 7 : london_ssth == "08" ? 8 : london_ssth == "09" ? 9 : london_ssth == "10" ? 10 : london_ssth == "11" ? 11 : london_ssth == "12" ? 12 : london_ssth == "13" ? 13 : london_ssth == "14" ? 14 : london_ssth == "15" ? 15 : london_ssth == "16" ? 16 : london_ssth == "17" ? 17 : london_ssth == "18" ? 18 : london_ssth == "19" ? 19 : london_ssth == "20" ? 20 : london_ssth == "21" ? 21 : london_ssth == "22" ? 22 : london_ssth == "23" ? 23 : 0
london_start_session_minute_int = london_sstm == "00" ? 0 : london_sstm == "15" ? 15 : london_sstm == "30" ? 30 : london_sstm == "45" ? 45 : 0

int london_end_session_hour_int = london_esth == "00" ? 0 : london_esth == "01" ? 1 : london_esth == "02" ? 2 : london_esth == "03" ? 3 : london_esth == "04" ? 4 : london_esth == "05" ? 5 : london_esth == "06" ? 6 : london_esth == "07" ? 7 : london_esth == "08" ? 8 : london_esth == "09" ? 9 : london_esth == "10" ? 10 : london_esth == "11" ? 11 : london_esth == "12" ? 12 : london_esth == "13" ? 13 : london_esth == "14" ? 14 : london_esth == "15" ? 15 : london_esth == "16" ? 16 : london_esth == "17" ? 17 : london_esth == "18" ? 18 : london_esth == "19" ? 19 : london_esth == "20" ? 20 : london_esth == "21" ? 21 : london_esth == "22" ? 22 : london_esth == "23" ? 23 : 0
london_end_session_minute_int = london_estm == "00" ? 0 : london_estm == "15" ? 15 : london_estm == "30" ? 30 : london_estm == "45" ? 45 : 0

// NY Session time conversions
int ny_start_session_hour_int = ny_ssth == "00" ? 0 : ny_ssth == "01" ? 1 : ny_ssth == "02" ? 2 : ny_ssth == "03" ? 3 : ny_ssth == "04" ? 4 : ny_ssth == "05" ? 5 : ny_ssth == "06" ? 6 : ny_ssth == "07" ? 7 : ny_ssth == "08" ? 8 : ny_ssth == "09" ? 9 : ny_ssth == "10" ? 10 : ny_ssth == "11" ? 11 : ny_ssth == "12" ? 12 : ny_ssth == "13" ? 13 : ny_ssth == "14" ? 14 : ny_ssth == "15" ? 15 : ny_ssth == "16" ? 16 : ny_ssth == "17" ? 17 : ny_ssth == "18" ? 18 : ny_ssth == "19" ? 19 : ny_ssth == "20" ? 20 : ny_ssth == "21" ? 21 : ny_ssth == "22" ? 22 : ny_ssth == "23" ? 23 : 0
ny_start_session_minute_int = ny_sstm == "00" ? 0 : ny_sstm == "15" ? 15 : ny_sstm == "30" ? 30 : ny_sstm == "45" ? 45 : 0

int ny_end_session_hour_int = ny_esth == "00" ? 0 : ny_esth == "01" ? 1 : ny_esth == "02" ? 2 : ny_esth == "03" ? 3 : ny_esth == "04" ? 4 : ny_esth == "05" ? 5 : ny_esth == "06" ? 6 : ny_esth == "07" ? 7 : ny_esth == "08" ? 8 : ny_esth == "09" ? 9 : ny_esth == "10" ? 10 : ny_esth == "11" ? 11 : ny_esth == "12" ? 12 : ny_esth == "13" ? 13 : ny_esth == "14" ? 14 : ny_esth == "15" ? 15 : ny_esth == "16" ? 16 : ny_esth == "17" ? 17 : ny_esth == "18" ? 18 : ny_esth == "19" ? 19 : ny_esth == "20" ? 20 : ny_esth == "21" ? 21 : ny_esth == "22" ? 22 : ny_esth == "23" ? 23 : 0
ny_end_session_minute_int = ny_estm == "00" ? 0 : ny_estm == "15" ? 15 : ny_estm == "30" ? 30 : ny_estm == "45" ? 45 : 0

// Build session strings
rth_ses = (user_ssth) + (user_sstm) + "-" + (user_esth) + user_estm
london_rth_ses = (london_ssth) + (london_sstm) + "-" + (london_esth) +  london_estm
ny_rth_ses = (ny_ssth) + (ny_sstm) + "-" + (ny_esth) + ny_estm

// ADR Calculation
adr(length) =>
    daily_range = high - low
    ta.sma(daily_range[1], length)

to_pips(val) =>
    is_forex_pips ? math.round(val/syminfo.mintick/10) : math.round(val/syminfo.mintick)

daily_adr = daily_adr_user
if (dayofweek == dayofweek.sunday)
    daily_adr := daily_adr + 1
if (dayofweek == dayofweek.saturday)
    daily_adr := daily_adr + 1

day_adr = request.security(syminfo.tickerid, 'D', adr(daily_adr_length), lookahead=barmerge.lookahead_on)
one_day = 1000 * 60 * 60 * 24

// Asian Session Range Construction
srcHi = high
srcLo = low

var float asian_hi = 10e-10
var float asian_lo = 10e10

startTimeDelta = 24 - start_session_hour_int + 1
startTimeAlignment() => (hour + startTimeDelta) > 24? 0 : 1
isStartTimeAlignment = startTimeAlignment()

endBoxTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and (hour + startTimeDelta) > 24? 0 : -1
isEndBoxTimeAlignment = endBoxTimeAlignment()

endTimeAlignment() => start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) > 24? 1 : start_session_hour_int >= end_session_hour_int and (hour + startTimeDelta) <= 24? 0 : start_session_hour_int < end_session_hour_int and isEndBoxTimeAlignment == 0? 1 : start_session_hour_int < end_session_hour_int and (hour + startTimeDelta) > 24? -1 : 0
isEndTimeAlignment = endTimeAlignment()

AsianFromDate = timestamp(year, month, dayofmonth - isStartTimeAlignment, start_session_hour_int, start_session_minute_int)
AsianToDate = timestamp(year, month, dayofmonth + isEndBoxTimeAlignment, end_session_hour_int, end_session_minute_int) - chart_time_period_int

asian_hi := ta.change(AsianFromDate) ? srcHi : math.max(srcHi, asian_hi)
asian_lo := ta.change(AsianFromDate) ? srcLo : math.min(srcLo, asian_lo)

inAsianSession = not na(time(timeframe.period, rth_ses))

asian_rth_open_bar = open_bar(rth_ses)
asian_rth_is_open = is_open(rth_ses)
asian_rth_low = float(na)
asian_rth_low := asian_rth_is_open ? asian_rth_open_bar ? low : math.min(asian_rth_low[1], low) : asian_rth_low[1]
asian_rth_high = float(na)
asian_rth_high := asian_rth_is_open ? asian_rth_open_bar ? high : math.max(asian_rth_high[1], high) : asian_rth_high[1]
asian_rth_mid = math.avg(asian_rth_low, asian_rth_high)

if showAsian and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    atrl = line.new(AsianFromDate, asian_rth_low, AsianToDate, asian_rth_low, xloc=xloc.bar_time, color=line_color, style=line.style_solid, width = boxLineWidth)
    line.delete(atrl[1])

    atrh = line.new(AsianFromDate, asian_rth_high, AsianToDate, asian_rth_high, xloc=xloc.bar_time, color=line_color, style=line.style_solid, width = boxLineWidth)
    line.delete(atrh[1])

    asianStartBox = line.new(AsianFromDate, asian_rth_high, AsianFromDate, asian_rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_color, style=line.style_solid, width=boxLineWidth)
    line.delete(asianStartBox[1])

    asianEndBox = line.new(AsianToDate, asian_rth_high, AsianToDate, asian_rth_low, extend=extend.none, xloc=xloc.bar_time, color=line_color, style=line.style_solid, width=boxLineWidth)
    line.delete(asianEndBox[1])

if showAsian and not inAsianSession and inAsianSession[1] and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    box.new(AsianFromDate[1], asian_rth_high[1], AsianToDate[1], asian_rth_low[1], border_color=line_color, bgcolor=color.new(line_color, 90), xloc=xloc.bar_time)
    label.new(math.round(math.avg(AsianFromDate[1], AsianToDate[1])), math.avg(asian_rth_high[1], asian_rth_low[1]), "A", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_center, line_color, size.small)

// London Session Range Construction
var float london_hi = 10e-10
var float london_lo = 10e10

londonStartTimeDelta = 24 - london_start_session_hour_int + 1
startLondonTimeAlignment() => (hour + londonStartTimeDelta) > 24? 0 : 1
isLondonStartTimeAlignment = startLondonTimeAlignment()

endLondonTimeAlignment() => (hour) >= (london_start_session_hour_int) and isLondonStartTimeAlignment == 0? 0 : 1
isLondonEndTimeAlignment = endLondonTimeAlignment()

LondonFromDate = timestamp(year, month, dayofmonth - isLondonStartTimeAlignment, london_start_session_hour_int, london_start_session_minute_int)
LondonToDate = timestamp(year, month, dayofmonth - isLondonEndTimeAlignment, london_end_session_hour_int, london_end_session_minute_int) - chart_time_period_int

london_hi := ta.change(LondonFromDate) ? srcHi : math.max(srcHi, london_hi)
london_lo := ta.change(LondonFromDate) ? srcLo : math.min(srcLo, london_lo)

inLondonSession = not na(time(timeframe.period, london_rth_ses))

london_rth_open_bar = open_bar(london_rth_ses)
london_rth_is_open = is_open(london_rth_ses)
london_rth_low = float(na)
london_rth_low := london_rth_is_open ? london_rth_open_bar ? low : math.min(london_rth_low[1], low) : london_rth_low[1]
london_rth_high = float(na)
london_rth_high := london_rth_is_open ? london_rth_open_bar ? high : math.max(london_rth_high[1], high) : london_rth_high[1]
london_rth_mid = math.avg(london_rth_low, london_rth_high)

if showLondon and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    ltrl = line.new(LondonFromDate, london_rth_low, LondonToDate, london_rth_low, xloc=xloc.bar_time, color=lline_color, style=line.style_solid, width = lboxLineWidth)
    line.delete(ltrl[1])

    ltrh = line.new(LondonFromDate, london_rth_high, LondonToDate, london_rth_high, xloc=xloc.bar_time, color=lline_color, style=line.style_solid, width = lboxLineWidth)
    line.delete(ltrh[1])

    londonStartBox = line.new(LondonFromDate, london_rth_high, LondonFromDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_color, style=line.style_solid, width=lboxLineWidth)
    line.delete(londonStartBox[1])

    londonEndBox = line.new(LondonToDate, london_rth_high, LondonToDate, london_rth_low, extend=extend.none, xloc=xloc.bar_time, color=lline_color, style=line.style_solid, width=lboxLineWidth)
    line.delete(londonEndBox[1])

if show_london_session_rng and showLondon and not inLondonSession and inLondonSession[1] and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    box.new(LondonFromDate[1], london_rth_high[1], LondonToDate[1], london_rth_low[1], border_color=lline_color, bgcolor=color.new(lline_color, 90), xloc=xloc.bar_time)
    label.new(math.round(math.avg(LondonFromDate[1], LondonToDate[1])), math.avg(london_rth_high[1], london_rth_low[1]), "L", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_center, lline_color, size.small)

// New York Session Range Construction
var float ny_hi = 10e-10
var float ny_lo = 10e10

nyStartTimeDelta = 24 - ny_start_session_hour_int + 1
startNyTimeAlignment() => (hour + nyStartTimeDelta) > 24? 0 : 1
isNyStartTimeAlignment = startNyTimeAlignment()

endNyTimeAlignment() => (hour) >= (ny_start_session_hour_int) and isNyStartTimeAlignment == 0? 0 : 1
isNyEndTimeAlignment = endNyTimeAlignment()

NyFromDate = timestamp(year, month, dayofmonth - isNyStartTimeAlignment, ny_start_session_hour_int, ny_start_session_minute_int)
NyToDate = timestamp(year, month, dayofmonth - isNyEndTimeAlignment, ny_end_session_hour_int, ny_end_session_minute_int) - chart_time_period_int

ny_hi := ta.change(NyFromDate) ? srcHi : math.max(srcHi, ny_hi)
ny_lo := ta.change(NyFromDate) ? srcLo : math.min(srcLo, ny_lo)

inNySession = not na(time(timeframe.period, ny_rth_ses))

ny_rth_open_bar = open_bar(ny_rth_ses)
ny_rth_is_open = is_open(ny_rth_ses)
ny_rth_low = float(na)
ny_rth_low := ny_rth_is_open ? ny_rth_open_bar ? low : math.min(ny_rth_low[1], low) : ny_rth_low[1]
ny_rth_high = float(na)
ny_rth_high := ny_rth_is_open ? ny_rth_open_bar ? high : math.max(ny_rth_high[1], high) : ny_rth_high[1]
ny_rth_mid = math.avg(ny_rth_low, ny_rth_high)

if showNY and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    ntrl = line.new(NyFromDate, ny_rth_low, NyToDate, ny_rth_low, xloc=xloc.bar_time, color=nline_color, style=line.style_solid, width = nboxLineWidth)
    line.delete(ntrl[1])

    ntrh = line.new(NyFromDate, ny_rth_high, NyToDate, ny_rth_high, xloc=xloc.bar_time, color=nline_color, style=line.style_solid, width = nboxLineWidth)
    line.delete(ntrh[1])

    nyStartBox = line.new(NyFromDate, ny_rth_high, NyFromDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_color, style=line.style_solid, width=nboxLineWidth)
    line.delete(nyStartBox[1])

    nyEndBox = line.new(NyToDate, ny_rth_high, NyToDate, ny_rth_low, extend=extend.none, xloc=xloc.bar_time, color=nline_color, style=line.style_solid, width=nboxLineWidth)
    line.delete(nyEndBox[1])

if show_ny_session_rng and showNY and not inNySession and inNySession[1] and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    box.new(NyFromDate[1], ny_rth_high[1], NyToDate[1], ny_rth_low[1], border_color=nline_color, bgcolor=color.new(nline_color, 90), xloc=xloc.bar_time)
    label.new(math.round(math.avg(NyFromDate[1], NyToDate[1])), math.avg(ny_rth_high[1], ny_rth_low[1]), "NY", xloc.bar_time, yloc.price, color.new(color.black,100), label.style_label_center, nline_color, size.small)

// Previous Day High/Low
getData(r, s) => request.security(syminfo.tickerid, r, s, barmerge.gaps_off, barmerge.lookahead_on)

pdh = getData('D', high[1])
pdl = getData('D', low[1])

lwh = getData('W', high[1])
lwl = getData('W', low[1])

start_support_hour_int = 17
start_support_minute_int = 0
end_support_hour_int = 17
end_support_minute_int = 0

supportStartTimeDelta = 24 - start_session_hour_int + 1
supportStartTimeAlignment() => (hour + supportStartTimeDelta) > 24? 0 : 1
isSupportStartTimeAlignment = supportStartTimeAlignment()

supportEndTimeAlignment() => (hour + supportStartTimeDelta) > 24? 1 : 0
isSupportEndTimeAlignment = supportEndTimeAlignment()

SupportFromDate = timestamp(year, month, dayofmonth - isSupportStartTimeAlignment, start_support_hour_int, start_support_minute_int)
SupportToDate = timestamp(year, month, dayofmonth + isSupportEndTimeAlignment, end_support_hour_int, end_support_minute_int) - chart_time_period_int

if showPreviousDayHiLo and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    yesterdayHighLine = line.new(SupportFromDate, pdh, SupportToDate, pdh, xloc=xloc.bar_time, extend=extend.right, color=support_line_color, style=line.style_dashed, width = supportLineWidth)
    line.delete(yesterdayHighLine[1])
    dailyHighLabel = label.new(math.round(math.avg(SupportFromDate, SupportToDate)), pdh, "ðð®ð¶ð¹ð ðð¶ð´ðµ", xloc=xloc.bar_time, yloc=yloc.price, color=color.new(color.black, 100), style=label.style_label_center, textcolor=color.black, size=size.normal)
    label.delete(dailyHighLabel[1])

    yesterdayLowLine = line.new(SupportFromDate, pdl, SupportToDate, pdl, xloc=xloc.bar_time, extend=extend.right, color=support_line_color, style=line.style_dashed, width = supportLineWidth)
    line.delete(yesterdayLowLine[1])
    dailyLowLabel = label.new(math.round(math.avg(SupportFromDate, SupportToDate)), pdl, "ðð®ð¶ð¹ð ðð¼ð", xloc=xloc.bar_time, yloc=yloc.price, color=color.new(color.black, 100), style=label.style_label_center, textcolor=color.black, size=size.normal)
    label.delete(dailyLowLabel[1])

if showLastWeeklyHiLo and timeframe.period != "D" and timeframe.period != "W" and timeframe.period != "M"
    weekLastHighLine = line.new(SupportFromDate, lwh, SupportToDate, lwh, xloc=xloc.bar_time, extend=extend.right, color=support_last_week_line_color, style=line.style_dashed, width = supportLastWeekLineWidth)
    line.delete(weekLastHighLine[1])
    weeklyHighLabel = label.new(math.round(math.avg(SupportFromDate, SupportToDate)), lwh, "ðªð²ð²ð¸ð¹ð ðð¶ð´ðµ", xloc=xloc.bar_time, yloc=yloc.price, color=color.new(color.black, 100), style=label.style_label_center, textcolor=color.black, size=size.normal)
    label.delete(weeklyHighLabel[1])

    weekLastLowLine = line.new(SupportFromDate, lwl, SupportToDate, lwl, xloc=xloc.bar_time, extend=extend.right, color=support_last_week_line_color, style=line.style_dashed, width = supportLastWeekLineWidth)
    line.delete(weekLastLowLine[1])
    weeklyLowLabel = label.new(math.round(math.avg(SupportFromDate, SupportToDate)), lwl, "ðªð²ð²ð¸ð¹ð ðð¼ð", xloc=xloc.bar_time, yloc=yloc.price, color=color.new(color.black, 100), style=label.style_label_center, textcolor=color.black, size=size.normal)
    label.delete(weeklyLowLabel[1])

//Pivotpoints
ph          = ta.pivothigh(3, 1), lPh = fixnan(ph)
pl          = ta.pivotlow (3, 1), lPl = fixnan(pl)

//Candles
L_body      =
 high - mx  < body * perc_Body and
 mn - low   < body * perc_Body

L_bodyUP    =   body > meanBody  and L_body and close > open
L_bodyDN    =   body > meanBody  and L_body and close < open

bsNOTbodyUP = ta.barssince(not L_bodyUP)
bsNOTbodyDN = ta.barssince(not L_bodyDN)

bsIs_bodyUP = ta.barssince(    L_bodyUP)
bsIs_bodyDN = ta.barssince(    L_bodyDN)

lwst        = math.min(lPh [bsNOTbodyUP[1]], low[bsNOTbodyUP[1]])
hgst        = math.max(high[bsNOTbodyDN[1]], lPl[bsNOTbodyDN[1]])

//Imbalance
imbalanceUP = L_bodyUP[1] and (i_FVG == 'FVG' ? low  > high[2] : low  < high[2])
imbalanceDN = L_bodyDN[1] and (i_FVG == 'FVG' ? high < low [2] : high > low [2])

//Volume Imbalance
vImb_Bl     = open > close[1] and high[1] > low  and close > close[1] and open > open[1] and high[1] < mn
vImb_Br     = open < close[1] and low [1] < high and close < close[1] and open < open[1] and low [1] > mx

if sVimbl
    if vImb_Bl
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mx[1], n +3, mx[1], color=cVimbl)
         , line.new (n   , mn   , n +3, mn   , color=cVimbl)
          , label.new(n +3, math.avg    (mx[1], mn), text='VI'
         , color=color(na) , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if vImb_Br
        Vimbal.unshift(
         _2ln_lb.new(
          line.new (n -1, mn[1], n +3, mn[1], color=cVimbl)
         , line.new (n   , mx   , n +3, mx   , color=cVimbl)
          , label.new(n +3, math.avg    (mn[1], mx), text='VI'
         , color=color(na) , textcolor=cVimbl, style=label.style_label_left)
          )
         )
    if Vimbal.size() > visVim
        pop = Vimbal.pop()
        pop.l1.delete()
        pop.l2.delete()
        pop.lb.delete()

//Fair Value Gap
if barstate.isfirst
    for i = 0 to visBxs -1
        bFVG_UP.unshift(FVG.new(box(na), false))
        bFVG_DN.unshift(FVG.new(box(na), false))
        if i_BPR
            bBPR_UP.unshift(FVG.new(box(na), false))
            bBPR_DN.unshift(FVG.new(box(na), false))

if imbalanceUP and per and shwFVG
    if imbalanceUP[1]
        bFVG_UP.get(0).box.set_lefttop    (n -2, low    )
        bFVG_UP.get(0).box.set_rightbottom(n +8, high[2])
    else
        bFVG_UP.unshift(FVG.new(
          box.new(
           n -2
         ,    i_FVG == 'FVG' ? low : high[2]
         , n, i_FVG == 'FVG' ? high[2] : low
         , bgcolor     = i_BPR ? color(na) : color.new(cFVGbl, 70)
         , border_color= i_BPR ? color(na) : color.new(cFVGbl, 65)
         , text_color  = i_BPR ? color(na) : color.new(cFVGbl, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_UP.pop().box.delete()

if imbalanceDN and per and shwFVG
    if imbalanceDN[1]
        bFVG_DN.get(0).box.set_lefttop    (n -2, low[2])
        bFVG_DN.get(0).box.set_rightbottom(n +8, high  )
    else
        bFVG_DN.unshift(FVG.new(
         box.new(
           n -2
         ,    i_FVG == 'FVG' ? low[2] : high
         , n, i_FVG == 'FVG' ? high   : low[2]
         , bgcolor     = i_BPR ? color(na) : color.new(cFVGbr, 70)
         , border_color= i_BPR ? color(na) : color.new(cFVGbr, 65)
         , text_color  = i_BPR ? color(na) : color.new(cFVGbr, 65)
         , text_size=size.small
         , text=i_FVG
         )
         , true)
         )
        bFVG_DN.pop().box.delete()

//Balance Price Range
if i_BPR and bFVG_UP.size() > 0 and bFVG_DN.size() > 0
    bxUP    = bFVG_UP.get(0)
    bxDN    = bFVG_DN.get(0)
    bxUPbtm = bxUP.box.get_bottom()
    bxDNbtm = bxDN.box.get_bottom()
    bxUPtop = bxUP.box.get_top()
    bxDNtop = bxDN.box.get_top()
    left    = math.min(bxUP.box.get_left (), bxDN.box.get_left ())
    right   = math.max(bxUP.box.get_right(), bxDN.box.get_right())
    //
    if bxUPbtm < bxDNtop and
       bxDNbtm < bxUPbtm
        if left == bBPR_UP.get(0).box.get_left()
            if  bBPR_UP.get(0).active
                bBPR_UP.get(0).box.set_right(right)
        else
            bBPR_UP.unshift(FVG.new(
             box.new(
              left, bxDNtop, right, bxUPbtm
              , bgcolor     = i_BPR ? color.new(cFVGbl, 70) : color(na)
              , border_color= i_BPR ? color.new(cFVGbl, 65) : color(na)
              , text_color  = i_BPR ? color.new(cFVGbl, 65) : color(na)
              , text_size=size.small
              , text= 'BPR'
              )
              , true
              , close > bxUPbtm ? 1 : close < bxDNtop ? -1 : 0
              )
             )
            bBPR_UP.pop().box.delete()
    //
    if bxDNbtm < bxUPtop and
       bxUPbtm < bxDNbtm
        if left == bBPR_DN.get(0).box.get_left()
            if  bBPR_DN.get(0).active
                bBPR_DN.get(0).box.set_right(right)
        else
            bBPR_DN.unshift(FVG.new(
             box.new(
              left, bxUPtop, right, bxDNbtm
              , bgcolor     = i_BPR ? color.new(cFVGbr, 70) : color(na)
              , border_color= i_BPR ? color.new(cFVGbr, 65) : color(na)
              , text_color  = i_BPR ? color.new(cFVGbr, 65) : color(na)
              , text_size=size.small
              , text= 'BPR'
              )
              , true
              , close > bxDNbtm ? 1 : close < bxUPtop ? -1 : 0
              )
             )
            bBPR_DN.pop().box.delete()

//FVG's breaks
for i = 0 to math.min(bxBack, bFVG_UP.size() -1)
    getUPi = bFVG_UP.get(i)
    if getUPi.active
        getUPi.box.set_right(bar_index +8)
        if low  < getUPi.box.get_top() and not i_BPR
            getUPi.box.set_border_style(line.style_dashed)
        if low  < getUPi.box.get_bottom()
            if not i_BPR
                getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                getUPi.box.set_border_style(line.style_dotted)
            getUPi.box.set_right(bar_index)
            getUPi.active := false

for i = 0 to math.min(bxBack, bFVG_DN.size() -1)
    getDNi = bFVG_DN.get(i)
    if getDNi.active
        getDNi.box.set_right(bar_index +8)
        if high > getDNi.box.get_bottom() and not i_BPR
            getDNi.box.set_border_style(line.style_dashed)
        if high > getDNi.box.get_top()
            if not i_BPR
                getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                getDNi.box.set_border_style(line.style_dotted)
            getDNi.box.set_right(bar_index)
            getDNi.active := false

if i_BPR
    for i = 0 to math.min(bxBack, bBPR_UP.size() -1)
        getUPi = bBPR_UP.get(i)
        if getUPi.active
            getUPi.box.set_right(bar_index +8)
            switch getUPi.pos
                -1 =>
                    if high > getUPi.box.get_bottom()
                        getUPi.box.set_border_style(line.style_dashed)
                    if high > getUPi.box.get_top   ()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false
                1 =>
                    if low  < getUPi.box.get_top   ()
                        getUPi.box.set_border_style(line.style_dashed)
                    if low  < getUPi.box.get_bottom()
                        getUPi.box.set_bgcolor(color.new(cFVGblBR, 95))
                        getUPi.box.set_border_style(line.style_dotted)
                        getUPi.box.set_right(bar_index)
                        getUPi.active := false

    for i = 0 to math.min(bxBack, bBPR_DN.size() -1)
        getDNi = bBPR_DN.get(i)
        if getDNi.active
            getDNi.box.set_right(bar_index +8)
            switch getDNi.pos
                -1 =>
                    if high > getDNi.box.get_bottom()
                        getDNi.box.set_border_style(line.style_dashed)
                    if high > getDNi.box.get_top   ()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false
                1 =>
                    if low  < getDNi.box.get_top   ()
                        getDNi.box.set_border_style(line.style_dashed)
                    if low  < getDNi.box.get_bottom()
                        getDNi.box.set_bgcolor(color.new(cFVGbrBR, 95))
                        getDNi.box.set_border_style(line.style_dotted)
                        getDNi.box.set_right(bar_index)
                        getDNi.active := false

//NWOG/NDOG
if barstate.isfirst
    for i = 0 to maxNWOG -1
        bl_NWOG.unshift(bx_ln.new(box(na), line(na)))
    for i = 0 to maxNDOG -1
        bl_NDOG.unshift(bx_ln.new(box(na), line(na)))

if dayofweek == dayofweek.friday
    friCp := close, friCi := n

if ta.change(dayofweek)
    if  dayofweek == dayofweek.monday and iNWOG
        monOp := open , monOi := n
        bl_NWOG.unshift(bx_ln.new(
         box.new(
           friCi        ,   math.max (friCp  , monOp  )
         , monOi        ,   math.min (friCp  , monOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNWOG2
         , extend       =             extend.right    )
         ,
         line.new(
           monOi        ,   math.avg (friCp  , monOp  )
         , monOi +1     ,   math.avg (friCp  , monOp  )
         , color        =             cNWOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )
         ))
        bl = bl_NWOG.pop(), bl.b.delete(), bl.l.delete()
    if iNDOG
        cuDOp := open    , cuDOi := n
        prDCp := close[1], prDCi := n -1
        //
        bl_NDOG.unshift(bx_ln.new(
         box.new(
           prDCi        ,   math.max (prDCp  , cuDOp  )
         , cuDOi        ,   math.min (prDCp  , cuDOp  )
         , bgcolor      =   color    ( na             )
         , border_color =             cNDOG2
         , extend       =             extend.right    )
         ,
         line.new(
           cuDOi        ,   math.avg (prDCp  , cuDOp  )
         , cuDOi +1     ,   math.avg (prDCp  , cuDOp  )
         , color        =             cNDOG1
         , style        =             line.style_dotted
         , extend       =             extend.right    )
         ))
        bl = bl_NDOG.pop(), bl.b.delete(), bl.l.delete()

//Liquidity
for i = 0 to b_liq_B.size() -1
    x = b_liq_B.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close > x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close > x.bx.get_bottom()
                x.brokenBtm := true
        if x.brokenBtm
            x.bx.set_bgcolor(color.new(cLIQ_B, 90))
            x.ln.delete()
            if x.brokenTop
                x.broken := true
                x.bx.set_right(n)

for i = 0 to b_liq_S.size() -1
    x = b_liq_S.get(i)
    if not x.broken
        x.bx.set_right(n +3)
        x.ln.set_x2   (n +3)
        if not x.brokenTop
            if close < x.bx.get_top   ()
                x.brokenTop := true
        if not x.brokenBtm
            if close < x.bx.get_bottom()
                x.brokenBtm := true
        if x.brokenTop
            x.bx.set_bgcolor(color.new(cLIQ_S, 90))
            x.ln.delete()
            if x.brokenBtm
                x.broken := true
                x.bx.set_right(n)

//-----------------------------------------------------------------------------}
// Order Blocks with Breaker & Propulsion Detection
//-----------------------------------------------------------------------------{
[top, btm] = swings(length)

// For detecting propulsion - track OB breach
var array<bool> ob_breaching_bull = array.new_bool()
var array<float> ob_breach_low_bull = array.new_float()
var array<float> ob_breach_high_bull = array.new_float()

var array<bool> ob_breaching_bear = array.new_bool()
var array<float> ob_breach_low_bear = array.new_float()
var array<float> ob_breach_high_bear = array.new_float()

// Sync arrays
if ob_breaching_bull.size() < bullish_ob.size()
    while ob_breaching_bull.size() < bullish_ob.size()
        ob_breaching_bull.push(false)
        ob_breach_low_bull.push(high)
        ob_breach_high_bull.push(low)

if ob_breaching_bear.size() < bearish_ob.size()
    while ob_breaching_bear.size() < bearish_ob.size()
        ob_breaching_bear.push(false)
        ob_breach_low_bear.push(high)
        ob_breach_high_bear.push(low)

if showOB and per
    if close > top.y and not top.crossed
        top.crossed := true

        minima = max[1]
        maxima = min[1]
        loc = time[1]

        for i = 1 to (n - top.x)-1
            minima := math.min(min[i], minima)
            maxima := minima == min[i] ? max[i] : maxima
            loc := minima == min[i] ? time[i] : loc
        bullish_ob.unshift(ob.new(maxima, minima, loc))
        // Add breach tracking arrays
        ob_breaching_bull.unshift(false)
        ob_breach_low_bull.unshift(high)
        ob_breach_high_bull.unshift(low)

    // Check Bullish OB for Breaker or Propulsion
    if bullish_ob.size() > 0
        for i = bullish_ob.size()-1 to 0
            element = bullish_ob.get(i)
            is_breaching = ob_breaching_bull.get(i)
            breach_low = ob_breach_low_bull.get(i)
            breach_high = ob_breach_high_bull.get(i)

            // Detect breach (dip into OB)
            if not element.breaker and low <= element.top and high > element.top and bar_index > time_to_bar_index(element.loc) + 1
                if not is_breaching
                    ob_breaching_bull.set(i, true)
                    ob_breach_low_bull.set(i, low)
                    ob_breach_high_bull.set(i, high)
                else
                    ob_breach_low_bull.set(i, math.min(breach_low, low))
                    ob_breach_high_bull.set(i, math.max(breach_high, high))

            // Propulsion: Price bounces from OB
            if is_breaching and close > element.top and showPB
                breach_high := ob_breach_high_bull.get(i)
                // Create Propulsion Block
                newPB = propulsion.new(breach_high, math.avg(breach_high, element.top), time_to_bar_index(element.loc), line.new(time_to_bar_index(element.loc), breach_high, n + 50, breach_high, extend=extend.right, color=cPBplus, width=2, style=line.style_solid), line.new(time_to_bar_index(element.loc), math.avg(breach_high, element.top), n + 50, math.avg(breach_high, element.top), extend=extend.right, color=color.new(cPBplus, 50), width=1, style=line.style_dotted), label.new(time_to_bar_index(element.loc), breach_high, 'PB+', color=color.new(color.white, 100), textcolor=color.green, size=size.small, style=label.style_label_upper_right), 1)
                a_propulsion_bull.unshift(newPB)
                // Remove OB (replaced by propulsion)
                bullish_ob.remove(i)
                ob_breaching_bull.remove(i)
                ob_breach_low_bull.remove(i)
                ob_breach_high_bull.remove(i)
                continue

            // Breaker: Price breaks below OB
            if not element.breaker
                if math.min(close, open) < element.btm and showBB
                    // Create Breaker Block
                    bbCenter = math.avg(element.top, element.btm)
                    newBB = breaker.new(element.top, element.btm, bbCenter, time_to_bar_index(element.loc), breakerShowBoxes ? box.new(time_to_bar_index(element.loc), element.top, n + 50, element.btm, border_color=cBB_minA, bgcolor=cBB_minA, extend=extend.right, xloc=xloc.bar_index) : box(na), line.new(time_to_bar_index(element.loc), bbCenter, n + 50, bbCenter, extend=extend.right, color=color.new(cBB_minA, 0), width=2, style=line.style_dashed), label.new(n, bbCenter, 'BB-', color=color.new(color.white, 100), textcolor=color.red, size=size.small, style=label.style_label_lower_right), false, -1)
                    a_breaker_bear.unshift(newBB)
                    // Remove OB
                    bullish_ob.remove(i)
                    ob_breaching_bull.remove(i)
                    ob_breach_low_bull.remove(i)
                    ob_breach_high_bull.remove(i)
                    continue

            // Standard mitigation/removal
            if element.breaker
                if close > element.top
                    bullish_ob.remove(i)
                    ob_breaching_bull.remove(i)
                    ob_breach_low_bull.remove(i)
                    ob_breach_high_bull.remove(i)
                else if i < showBull and top.y < element.top and top.y > element.btm
                    blBrkConf := 1

    // Label for polarity change
    if blBrkConf > blBrkConf[1] and showLabels
        label.new(top.x, top.y, 'â¼', color = na
          , textcolor = bearCss.notransp()
          , style = label.style_label_down
          , size = size.tiny)

    // Bearish OB
    if close < btm.y and not btm.crossed
        btm.crossed := true

        minima = min[1]
        maxima = max[1]
        loc = time[1]

        for i = 1 to (n - btm.x)-1
            maxima := math.max(max[i], maxima)
            minima := maxima == max[i] ? min[i] : minima
            loc := maxima == max[i] ? time[i] : loc
        bearish_ob.unshift(ob.new(maxima, minima, loc))
        ob_breaching_bear.unshift(false)
        ob_breach_low_bear.unshift(high)
        ob_breach_high_bear.unshift(low)

    // Check Bearish OB for Breaker or Propulsion
    if bearish_ob.size() > 0
        for i = bearish_ob.size()-1 to 0
            element = bearish_ob.get(i)
            is_breaching = ob_breaching_bear.get(i)
            breach_low = ob_breach_low_bear.get(i)
            breach_high = ob_breach_high_bear.get(i)

            // Detect breach
            if not element.breaker and high >= element.btm and low < element.btm and bar_index > time_to_bar_index(element.loc) + 1
                if not is_breaching
                    ob_breaching_bear.set(i, true)
                    ob_breach_low_bear.set(i, low)
                    ob_breach_high_bear.set(i, high)
                else
                    ob_breach_low_bear.set(i, math.min(breach_low, low))
                    ob_breach_high_bear.set(i, math.max(breach_high, high))

            // Propulsion
            if is_breaching and close < element.btm and showPB
                breach_low := ob_breach_low_bear.get(i)
                newPB = propulsion.new(breach_low, math.avg(breach_low, element.btm), time_to_bar_index(element.loc), line.new(time_to_bar_index(element.loc), breach_low, n + 50, breach_low, extend=extend.right, color=cPBminus, width=2, style=line.style_solid), line.new(time_to_bar_index(element.loc), math.avg(breach_low, element.btm), n + 50, math.avg(breach_low, element.btm), extend=extend.right, color=color.new(cPBminus, 50), width=1, style=line.style_dotted), label.new(time_to_bar_index(element.loc), breach_low, 'PB-', color=color.new(color.white, 100), textcolor=color.red, size=size.small, style=label.style_label_lower_right), -1)
                a_propulsion_bear.unshift(newPB)
                bearish_ob.remove(i)
                ob_breaching_bear.remove(i)
                ob_breach_low_bear.remove(i)
                ob_breach_high_bear.remove(i)
                continue

            // Breaker
            if not element.breaker
                if math.max(close, open) > element.top and showBB
                    bbCenter = math.avg(element.top, element.btm)
                    newBB = breaker.new(element.top, element.btm, bbCenter, time_to_bar_index(element.loc), breakerShowBoxes ? box.new(time_to_bar_index(element.loc), element.top, n + 50, element.btm, border_color=cBBplusA, bgcolor=cBBplusA, extend=extend.right, xloc=xloc.bar_index) : box(na), line.new(time_to_bar_index(element.loc), bbCenter, n + 50, bbCenter, extend=extend.right, color=color.new(cBBplusA, 0), width=2, style=line.style_dashed), label.new(n, bbCenter, 'BB+', color=color.new(color.white, 100), textcolor=color.green, size=size.small, style=label.style_label_upper_right), false, 1)
                    a_breaker_bull.unshift(newBB)
                    bearish_ob.remove(i)
                    ob_breaching_bear.remove(i)
                    ob_breach_low_bear.remove(i)
                    ob_breach_high_bear.remove(i)
                    continue

            if element.breaker
                if close < element.btm
                    bearish_ob.remove(i)
                    ob_breaching_bear.remove(i)
                    ob_breach_low_bear.remove(i)
                    ob_breach_high_bear.remove(i)
                else if i < showBear and btm.y > element.btm and btm.y < element.top
                    brBrkConf := 1

    if brBrkConf > brBrkConf[1] and showLabels
        label.new(btm.x, btm.y, 'â²', color = na
          , textcolor = bullCss.notransp()
          , style = label.style_label_up
          , size = size.tiny)

//-----------------------------------------------------------------------------}
// Update Breaker Blocks
//-----------------------------------------------------------------------------{
if showBB and a_breaker_bull.size() > 0
    for i = a_breaker_bull.size() - 1 to 0
        bb = a_breaker_bull.get(i)
        bb.ln.set_color(color.new(color.white, 100))
        if not bb.mitigated
            if close < bb.btm
                bb.mitigated := true
                if breakerShowBoxes
                    bb.bx.set_bgcolor(color.new(cBBplusA, 95))

if showBB and a_breaker_bear.size() > 0
    for i = a_breaker_bear.size() - 1 to 0
        bb = a_breaker_bear.get(i)
        bb.ln.set_color(color.new(color.white, 100))
        if not bb.mitigated
            if close > bb.top
                bb.mitigated := true
                if breakerShowBoxes
                    bb.bx.set_bgcolor(color.new(cBB_minA, 95))

// Limit Breaker count
if a_breaker_bull.size() > bbMaxCount
    for i = 0 to a_breaker_bull.size() - bbMaxCount - 1
        old = a_breaker_bull.pop()
        if breakerShowBoxes
            old.bx.delete()
        old.ln.delete()
        old.lb.delete()

if a_breaker_bear.size() > bbMaxCount
    for i = 0 to a_breaker_bear.size() - bbMaxCount - 1
        old = a_breaker_bear.pop()
        if breakerShowBoxes
            old.bx.delete()
        old.ln.delete()
        old.lb.delete()

//-----------------------------------------------------------------------------}
// Update Propulsion Blocks
//-----------------------------------------------------------------------------{
if showPB and a_propulsion_bull.size() > 0
    for i = a_propulsion_bull.size() - 1 to 0
        pb = a_propulsion_bull.get(i)
        if not pbShowMean
            pb.mline.set_color(color.new(color.white, 100))
        if close < pb.price
            pb.pline.delete()
            pb.mline.delete()
            pb.lb.delete()
            a_propulsion_bull.remove(i)

if showPB and a_propulsion_bear.size() > 0
    for i = a_propulsion_bear.size() - 1 to 0
        pb = a_propulsion_bear.get(i)
        if not pbShowMean
            pb.mline.set_color(color.new(color.white, 100))
        if close > pb.price
            pb.pline.delete()
            pb.mline.delete()
            pb.lb.delete()
            a_propulsion_bear.remove(i)

// Limit Propulsion count
if a_propulsion_bull.size() > pbMaxCount
    for i = 0 to a_propulsion_bull.size() - pbMaxCount - 1
        old = a_propulsion_bull.pop()
        old.pline.delete()
        old.mline.delete()
        old.lb.delete()

if a_propulsion_bear.size() > pbMaxCount
    for i = 0 to a_propulsion_bear.size() - pbMaxCount - 1
        old = a_propulsion_bear.pop()
        old.pline.delete()
        old.mline.delete()
        old.lb.delete()

//-----------------------------------------------------------------------------}
// Mitigation Blocks
//-----------------------------------------------------------------------------{
if showMB and mbShowBull
    bullishMB = close[1] > open[1] and low <= low[1] and close > low[1]
    if bullishMB
        newMB = mitblock.new(high[1], low[1], n - 1, box.new(n - 1, high[1], n + 20, low[1], bgcolor=mbBullColor, border_color=color.new(color.green, 100)), label.new(n + 20, low[1], 'MB+', style=label.style_label_upper_right, color=color.new(color.white, 100), textcolor=color.green, size=size.tiny))
        a_mitblock_bull.unshift(newMB)

if showMB and mbShowBear
    bearishMB = close[1] < open[1] and high >= high[1] and close < high[1]
    if bearishMB
        newMB = mitblock.new(high[1], low[1], n - 1, box.new(n - 1, high[1], n + 20, low[1], bgcolor=mbBearColor, border_color=color.new(color.red, 100)), label.new(n + 20, high[1], 'MB-', style=label.style_label_lower_right, color=color.new(color.white, 100), textcolor=color.red, size=size.tiny))
        a_mitblock_bear.unshift(newMB)

// Cleanup old mitigation blocks
if a_mitblock_bull.size() > mbLookback
    old = a_mitblock_bull.pop()
    old.bx.delete()
    old.lb.delete()

if a_mitblock_bear.size() > mbLookback
    old = a_mitblock_bear.pop()
    old.bx.delete()
    old.lb.delete()

//-----------------------------------------------------------------------------}
//Set Order Blocks
//-----------------------------------------------------------------------------{
if barstate.islast and showOB
    if a_bx_ln_lb.size() > 0
        for i = a_bx_ln_lb.size() -1 to 0
            item = a_bx_ln_lb.remove(i)
            item.bx.delete()
            item.ln.delete()
            item.lb.delete()
    //Bullish
    if showBull > 0
        blSz = bullish_ob.size()
        if blSz > 0
            for i = 0 to math.min(showBull, bullish_ob.size()) -1
                get_ob = bullish_ob.get(i)
                get_ob.display(bullCss, bullBrkCss, 'bl')
    //Bearish
    if showBear > 0
        brSz = bearish_ob.size()
        if brSz > 0
            for i = 0 to math.min(showBear, bearish_ob.size()) -1
                get_ob = bearish_ob.get(i)
                get_ob.display(bearCss, bearBrkCss, 'br')

//-----------------------------------------------------------------------------}
//Fibonacci
//-----------------------------------------------------------------------------{
if barstate.islast
    x1 = 0, y1 = 0., x2 = 0, y2 = 0., box up = na, box dn = na
    switch iFib
        'FVG'   =>
            if bFVG_UP.size() > 0 and bFVG_DN.size() > 0
                up  := bFVG_UP.get(0).box
                dn  := bFVG_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ?
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'BPR'   =>
            if bBPR_UP.size() > 0 and bBPR_DN.size() > 0
                up  := bBPR_UP.get(0).box
                dn  := bBPR_DN.get(0).box
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left  () : up.get_left  ()
                x2  := dnFirst ? up.get_right () : dn.get_right ()
                y1  := dnFirst ?
                 dnBottm       ? dn.get_bottom() : dn.get_top   () :
                 dnBottm       ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm       ? up.get_top   () : up.get_bottom() :
                 dnBottm       ? dn.get_bottom() : dn.get_top   ()
        'OB'    =>
            oSz = a_bx_ln_lb.size()
            if oSz > 1
                xA = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_x1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_left  ()
                 )
                xB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_x1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_left  ()
                 )
                AFirst = xB > xA
                //
                yAT = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_top   ()
                 )
                yAB = nz(
                   a_bx_ln_lb.get(oSz -1).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -1).bx.get_bottom()
                 )
                yBT = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_top   ()
                 )
                yBB = nz(
                   a_bx_ln_lb.get(oSz -2).ln.get_y1    ()
                 , a_bx_ln_lb.get(oSz -2).bx.get_bottom()
                 )
                ABottom = yAB < yBB
                //
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ?
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ?
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'Liq'   =>
            if b_liq_B.size() > 0 and b_liq_S.size() > 0
                xA = nz(
                   b_liq_B.get(0).ln.get_x1    ()
                 , b_liq_B.get(0).bx.get_left  ()
                 )
                xB = nz(
                   b_liq_S.get(0).ln.get_x1    ()
                 , b_liq_S.get(0).bx.get_left  ()
                 )
                AFirst = xB > xA
                //
                yAT = nz(
                   b_liq_B.get(0).ln.get_y1    ()
                 , b_liq_B.get(0).bx.get_top   ()
                 )
                yAB = nz(
                   b_liq_B.get(0).ln.get_y1    ()
                 , b_liq_B.get(0).bx.get_bottom()
                 )
                yBT = nz(
                   b_liq_S.get(0).ln.get_y1    ()
                 , b_liq_S.get(0).bx.get_top   ()
                 )
                yBB = nz(
                   b_liq_S.get(0).ln.get_y1    ()
                 , b_liq_S.get(0).bx.get_bottom()
                 )
                ABottom = yAB < yBB
                //
                x1  := AFirst ? xA : xB
                x2  := AFirst ? xB : xA
                y1  := AFirst ?
                 ABottom ? yAB : yAT :
                 ABottom ? yBT : yBB
                y2  := AFirst ?
                 ABottom ? yBT : yBB :
                 ABottom ? yAB : yAT
        'VI'    =>
            if Vimbal.size() > 1
                AxA = Vimbal.get(1).l2.get_x1(), AxB = Vimbal.get(1).l1.get_x1()
                BxA = Vimbal.get(0).l2.get_x1(), BxB = Vimbal.get(0).l1.get_x1()
                AyA = Vimbal.get(1).l2.get_y1(), AyB = Vimbal.get(1).l1.get_y1()
                ByA = Vimbal.get(0).l2.get_y1(), ByB = Vimbal.get(0).l1.get_y1()
                ABt = math.min(ByA, ByB) > math.min(AyA, AyB)
                x1 := math.max(AxA, AxB)
                x2 := math.max(BxA, BxB)
                y1 := ABt ? math.min(AyA, AyB) : math.max(AyA, AyB)
                y2 := ABt ? math.max(ByA, ByB) : math.min(ByA, ByB)
        'NWOG'  =>
            if bl_NWOG.size() > 1
                up  := bl_NWOG.get(0).b
                dn  := bl_NWOG.get(1).b
                dnFirst = up.get_left() > dn.get_left()
                dnBottm = up.get_top () > dn.get_top ()
                x1  := dnFirst ? dn.get_left () : up.get_left ()
                x2  := dnFirst ? up.get_right() : dn.get_right()
                y1  := dnFirst ?
                 dnBottm ? dn.get_bottom() : dn.get_top   () :
                 dnBottm ? up.get_top   () : up.get_bottom()
                y2  := dnFirst ?
                 dnBottm ? up.get_top   () : up.get_bottom() :
                 dnBottm ? dn.get_bottom() : dn.get_top   ()
    //
    if iFib != 'NONE'
        rt = math.max(x1, x2)
        lt = math.min(x1, x2)
        tp = math.max(y1, y2)
        bt = math.min(y1, y2)
        _0 = rt == x1 ? y1 : y2
        _1 = rt == x1 ? y2 : y1
        //
        df = _1 - _0
        m0236 = df * 0.236
        m0382 = df * 0.382
        m0500 = df * 0.500
        m0618 = df * 0.618
        m0786 = df * 0.786
        m1618 = df * 1.618
        //
        _diag.setLine(x1, y1        , x2       , y2        )
        _vert.setLine(rt, _0        , rt       , _0 + m1618)
        _zero.setLine(rt, _0        , rt + plus, _0        )
        _0236.setLine(rt, _0 + m0236, rt + plus, _0 + m0236)
        _0382.setLine(rt, _0 + m0382, rt + plus, _0 + m0382)
        _0500.setLine(rt, _0 + m0500, rt + plus, _0 + m0500)
        _0618.setLine(rt, _0 + m0618, rt + plus, _0 + m0618)
        _0786.setLine(rt, _0 + m0786, rt + plus, _0 + m0786)
        _one_.setLine(rt, _1        , rt + plus, _1        )
        _1618.setLine(rt, _0 + m1618, rt + plus, _0 + m1618)

//-----------------------------------------------------------------------------}
//Displacement
//-----------------------------------------------------------------------------{
plotshape(sDispl ? per       ?
     L_bodyUP    ? low  : na : na : na
     , title     = 'Displacement UP'
     , style     = shape.labelup
     , color     = color.lime
     , location  = location.belowbar)
plotshape(sDispl ? per       ?
     L_bodyDN    ? high : na : na : na
     , title     = 'Displacement DN'
     , style     = shape.labeldown
     , color     = color.red
     , location  = location.abovebar)

//-----------------------------------------------------------------------------}