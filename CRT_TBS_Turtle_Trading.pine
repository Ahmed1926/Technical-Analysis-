// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© Claude - Complete ICT Trading System
// Combining CRT, TBS, Turtle Trading, Multi-Timeframe Intrabar, VWAP, and SMT Divergence

//@version=5
indicator("Complete ICT Trading System", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500, max_bars_back=5000)

// Explicitly set max_bars_back for key variables
max_bars_back(time, 5000)
max_bars_back(high, 5000)
max_bars_back(low, 5000)
max_bars_back(close, 5000)
max_bars_back(open, 5000)

//-----------------------------------------------------------------------------}
//Input Settings
//-----------------------------------------------------------------------------{

// === CLASSIC TURTLE TRADING SETTINGS ===
turtleGroup = "Classic Turtle Trading"
showDonchian = input.bool(false, "Show Donchian Channels", group=turtleGroup)
donchian20Period = input.int(20, "Donchian 20 Period", minval=5, maxval=100, group=turtleGroup)
donchian55Period = input.int(55, "Donchian 55 Period", minval=20, maxval=200, group=turtleGroup)
showATR = input.bool(false, "Show ATR Stops", group=turtleGroup)
atrPeriod = input.int(14, "ATR Period", minval=5, maxval=50, group=turtleGroup)
atrMultiplier = input.float(2.0, "ATR Stop Multiplier", minval=0.5, maxval=5.0, step=0.5, group=turtleGroup)

donchian20Color = input.color(color.new(color.blue, 80), "Donchian 20 Color", group=turtleGroup, inline="d20")
donchian55Color = input.color(color.new(color.purple, 80), "Donchian 55 Color", group=turtleGroup, inline="d55")

// === CRT (CANDLE RANGE THEORY) SETTINGS ===
crtGroup = "Candle Range Theory (CRT)"
showCRT = input.bool(false, "Show CRT A-M-D Pattern", group=crtGroup)
crtLookback = input.int(50, "CRT Pattern Lookback", minval=20, maxval=200, group=crtGroup)
accumulationColor = input.color(color.new(color.yellow, 70), "Accumulation Box", group=crtGroup, inline="crt1")
manipulationColor = input.color(color.new(color.orange, 70), "Manipulation Box", group=crtGroup, inline="crt2")
distributionColor = input.color(color.new(color.green, 70), "Distribution (Bullish)", group=crtGroup, inline="crt3")
distributionBearColor = input.color(color.new(color.red, 70), "Distribution (Bearish)", group=crtGroup, inline="crt4")

showTP = input.bool(true, "Show TP Levels", group=crtGroup)
tp1Color = input.color(color.new(color.lime, 50), "TP1 (50%)", group=crtGroup, inline="tp1")
tp2Color = input.color(color.new(color.green, 50), "TP2 (100%)", group=crtGroup, inline="tp2")

// === TURTLE SOUP (TBS) SETTINGS ===
tbsGroup = "Turtle Soup (TBS)"
showTBS = input.bool(false, "Show Turtle Soup Signals", group=tbsGroup)
tbsSwingPeriod = input.int(20, "Swing High/Low Period", minval=5, maxval=100, group=tbsGroup)
tbsMaxWickPercent = input.float(30, "Max Wick % for TBS", minval=10, maxval=80, step=5, group=tbsGroup, tooltip="Max percentage of candle that can be wick for valid TBS")
bullTBSColor = input.color(color.new(color.lime, 0), "Bullish TBS", group=tbsGroup, inline="tbs1")
bearTBSColor = input.color(color.new(color.red, 0), "Bearish TBS", group=tbsGroup, inline="tbs2")

// === SIGNAL SETTINGS ===
signalGroup = "Entry/Exit Signals"
showEntrySignals = input.bool(false, "Show Entry Signals", group=signalGroup)
showExitSignals = input.bool(false, "Show Exit Signals", group=signalGroup)
combineSignals = input.bool(true, "Combine TBS + CRT Signals", group=signalGroup, tooltip="Require both TBS and CRT confirmation for entry")

// === MULTI-TIMEFRAME INTRABAR SETTINGS ===
var g_TF = "Multi-Timeframe Intrabar"
use_tf1         = input.bool(false, "30 Minutes", inline = "TF1", group = g_TF)
tf1             = input.timeframe("30", "", inline = "TF1", group = g_TF)
tf1_color       = input.color(color.new(#FF1493, 70), "", inline = "TF1", group = g_TF)
use_tf1_mid     = input.bool(true, "50% Level", inline = "TF1M", group = g_TF)
tf1_mid_color   = input.color(color.new(#FF1493, 50), "", inline = "TF1M", group = g_TF)

use_tf2         = input.bool(false, "1 Hour", inline = "TF2", group = g_TF)
tf2             = input.timeframe("60", "", inline = "TF2", group = g_TF)
tf2_color       = input.color(color.new(#FF4500, 70), "", inline = "TF2", group = g_TF)
use_tf2_mid     = input.bool(true, "50% Level", inline = "TF2M", group = g_TF)
tf2_mid_color   = input.color(color.new(#FF4500, 50), "", inline = "TF2M", group = g_TF)

use_tf3         = input.bool(false, "2 Hours", inline = "TF3", group = g_TF)
tf3             = input.timeframe("120", "", inline = "TF3", group = g_TF)
tf3_color       = input.color(color.new(#32CD32, 70), "", inline = "TF3", group = g_TF)
use_tf3_mid     = input.bool(true, "50% Level", inline = "TF3M", group = g_TF)
tf3_mid_color   = input.color(color.new(#32CD32, 50), "", inline = "TF3M", group = g_TF)

use_tf4         = input.bool(true, "4 Hours", inline = "TF4", group = g_TF)
tf4             = input.timeframe("240", "", inline = "TF4", group = g_TF)
tf4_color       = input.color(color.new(#1E90FF, 70), "", inline = "TF4", group = g_TF)
use_tf4_mid     = input.bool(true, "50% Level", inline = "TF4M", group = g_TF)
tf4_mid_color   = input.color(color.new(#1E90FF, 50), "", inline = "TF4M", group = g_TF)

use_tf5         = input.bool(true, "Daily", inline = "TF5", group = g_TF)
tf5             = input.timeframe("D", "", inline = "TF5", group = g_TF)
tf5_color       = input.color(color.new(#9932CC, 70), "", inline = "TF5", group = g_TF)
use_tf5_mid     = input.bool(true, "50% Level", inline = "TF5M", group = g_TF)
tf5_mid_color   = input.color(color.new(#9932CC, 50), "", inline = "TF5M", group = g_TF)

use_tf6         = input.bool(true, "Weekly", inline = "TF6", group = g_TF)
tf6             = input.timeframe("W", "", inline = "TF6", group = g_TF)
tf6_color       = input.color(color.new(#FFD700, 70), "", inline = "TF6", group = g_TF)
use_tf6_mid     = input.bool(true, "50% Level", inline = "TF6M", group = g_TF)
tf6_mid_color   = input.color(color.new(#FFD700, 50), "", inline = "TF6M", group = g_TF)

use_tf7         = input.bool(true, "Monthly", inline = "TF7", group = g_TF)
tf7             = input.timeframe("M", "", inline = "TF7", group = g_TF)
tf7_color       = input.color(color.new(#FF69B4, 70), "", inline = "TF7", group = g_TF)
use_tf7_mid     = input.bool(true, "50% Level", inline = "TF7M", group = g_TF)
tf7_mid_color   = input.color(color.new(#FF69B4, 50), "", inline = "TF7M", group = g_TF)

var g_TF_OPT = "MTF Options"
minbars         = input.int(1, "Minimum Bars", group = g_TF_OPT)
maxbars         = input.int(250, "Maximum Bars", group = g_TF_OPT)
hllinewidth     = input.int(2, "High/Low Line Width", group = g_TF_OPT)
midlinewidth    = input.int(1, "Mid Line Width", group = g_TF_OPT)

var g_TF_LABEL = "MTF Label Options"
bullishLabelStyle = input.string("Label Up", "Bullish Label Style", options=["None", "Label Up", "Label Down", "Label Left", "Label Right", "Label Center", "Triangle Up", "Triangle Down", "Flag", "Circle", "Square", "Diamond", "Cross", "X-Cross", "Arrow Up", "Arrow Down"], group=g_TF_LABEL)
bearishLabelStyle = input.string("Label Down", "Bearish Label Style", options=["None", "Label Up", "Label Down", "Label Left", "Label Right", "Label Center", "Triangle Up", "Triangle Down", "Flag", "Circle", "Square", "Diamond", "Cross", "X-Cross", "Arrow Up", "Arrow Down"], group=g_TF_LABEL)
labelSize = input.string("Small", "Label Size", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], group=g_TF_LABEL)

bullishBgColor = input.color(color.new(color.green, 50), "Bullish Background Color", group=g_TF_LABEL)
bullishTextColor = input.color(color.green, "Bullish Text Color", group=g_TF_LABEL)
bearishBgColor = input.color(color.new(color.red, 50), "Bearish Background Color", group=g_TF_LABEL)
bearishTextColor = input.color(color.red, "Bearish Text Color", group=g_TF_LABEL)

show_m30_labels = input.bool(false, "Show M30 Labels", group = g_TF_LABEL)
show_h1_labels  = input.bool(false, "Show H1 Labels", group = g_TF_LABEL)
show_h2_labels  = input.bool(false, "Show H2 Labels", group = g_TF_LABEL)
show_h4_labels  = input.bool(true, "Show H4 Labels", group = g_TF_LABEL)
show_daily_labels = input.bool(true, "Show Daily Labels", group = g_TF_LABEL)
show_weekly_labels = input.bool(true, "Show Weekly Labels", group = g_TF_LABEL)
show_monthly_labels = input.bool(true, "Show Monthly Labels", group = g_TF_LABEL)
max_labels      = input.int(50, "Maximum number of labels to show", minval=1, maxval=500, group = g_TF_LABEL)
show_eol_labels = input.bool(true, "Show End-of-Line Labels", group = g_TF_LABEL)
eol_label_offset = input.int(5, "End-of-Line Label Offset", minval=1, maxval=50, group = g_TF_LABEL)

var g_TF_TOUCH = "MTF Touch Options"
use_wick_touch = input.bool(true, "Use Wick Touch", group=g_TF_TOUCH)
use_body_touch = input.bool(true, "Use Body Touch", group=g_TF_TOUCH)

// === VWAP SETTINGS ===
vwapGroup = "VWAP"
showVWAP = input.bool(true, "Show VWAP", group=vwapGroup)
vwapColor = input.color(color.new(color.yellow, 0), "VWAP Color", group=vwapGroup)
vwapLineWidth = input.int(2, "VWAP Line Width", minval=1, maxval=5, group=vwapGroup)

// === SMT DIVERGENCE SETTINGS ===
smtGroup = "SMT Divergence"
showSMT = input.bool(true, "Show SMT Divergence", group=smtGroup)
smtSymbol = input.symbol('XAUUSD', 'Second Symbol', group=smtGroup)
smtPivotPeriod = input.int(2, "Divergence Fractal Periods", minval=1, group=smtGroup)
showBullSMTLine = input.bool(true, 'Show SMT Divergence Line from Bottom', group=smtGroup)
showBullSMTLabel = input.bool(true, 'Show SMT Divergence Label from Bottom', group=smtGroup)
showBearSMTLine = input.bool(true, 'Show SMT Divergence Line from Top', group=smtGroup)
showBearSMTLabel = input.bool(true, 'Show SMT Divergence Label from Top', group=smtGroup)

// === NO WICK CANDLESTICK SETTINGS ===
noWickGroup = "No Wick Candlestick"
showNoWick = input.bool(true, "Show No Wick Candlesticks", group=noWickGroup)
showNoWickShapes = input.bool(true, "Show Triangles", group=noWickGroup)
showNoWickLines = input.bool(true, "Show Compensation Lines", group=noWickGroup)
showNoWickLabels = input.bool(true, "Show Compensation Labels", group=noWickGroup)
noWickBullColor = input.color(color.new(color.green, 0), "Bullish No Wick", group=noWickGroup, inline="nw1")
noWickBearColor = input.color(color.new(color.red, 0), "Bearish No Wick", group=noWickGroup, inline="nw1")
noWickLineColor = input.color(color.new(#FFAE35, 5), "Compensation Line", group=noWickGroup)


//-----------------------------------------------------------------------------}
//Classic Turtle Trading - Donchian Channels
//-----------------------------------------------------------------------------{

// Donchian 20
donchian20High = ta.highest(high, donchian20Period)
donchian20Low = ta.lowest(low, donchian20Period)
donchian20Mid = (donchian20High + donchian20Low) / 2

// Donchian 55
donchian55High = ta.highest(high, donchian55Period)
donchian55Low = ta.lowest(low, donchian55Period)
donchian55Mid = (donchian55High + donchian55Low) / 2

// Plot Donchian Channels
p1 = plot(showDonchian ? donchian20High : na, "Donchian 20 High", color=donchian20Color, linewidth=1)
p2 = plot(showDonchian ? donchian20Low : na, "Donchian 20 Low", color=donchian20Color, linewidth=1)
fill(p1, p2, color=color.new(donchian20Color, 90))

p3 = plot(showDonchian ? donchian55High : na, "Donchian 55 High", color=donchian55Color, linewidth=2)
p4 = plot(showDonchian ? donchian55Low : na, "Donchian 55 Low", color=donchian55Color, linewidth=2)
fill(p3, p4, color=color.new(donchian55Color, 95))

//-----------------------------------------------------------------------------}
//ATR Calculation and Stops
//-----------------------------------------------------------------------------{

atrValue = ta.atr(atrPeriod)

// ATR-based stops
var float longStopPrice = na
var float shortStopPrice = na

// Update stops on breakout
if close > donchian55High[1]
    longStopPrice := close - (atrValue * atrMultiplier)

if close < donchian55Low[1]
    shortStopPrice := close + (atrValue * atrMultiplier)

// Trail stops
if not na(longStopPrice)
    longStopPrice := math.max(longStopPrice, close - (atrValue * atrMultiplier))

if not na(shortStopPrice)
    shortStopPrice := math.min(shortStopPrice, close + (atrValue * atrMultiplier))

// Plot ATR stops
plot(showATR and not na(longStopPrice) ? longStopPrice : na, "Long Stop", color=color.new(color.red, 0), style=plot.style_cross, linewidth=2)
plot(showATR and not na(shortStopPrice) ? shortStopPrice : na, "Short Stop", color=color.new(color.lime, 0), style=plot.style_cross, linewidth=2)

//-----------------------------------------------------------------------------}
//Turtle Soup (TBS) Detection
//-----------------------------------------------------------------------------{

// Identify swing highs and lows
swingHigh = ta.highest(high, tbsSwingPeriod)
swingLow = ta.lowest(low, tbsSwingPeriod)

// Bullish Turtle Soup: Price breaks below swing low but closes back inside
bullishTBS = false
bearishTBS = false

if showTBS
    // Bullish TBS: Low breaks below previous swing low, but close is above it (false breakdown)
    wickPercent = (high - close) / (high - low) * 100
    bullishTBS := low < swingLow[1] and close > swingLow[1] and wickPercent < tbsMaxWickPercent

    // Bearish TBS: High breaks above previous swing high, but close is below it (false breakout)
    wickPercentBear = (close - low) / (high - low) * 100
    bearishTBS := high > swingHigh[1] and close < swingHigh[1] and wickPercentBear < tbsMaxWickPercent

// Plot TBS signals
plotshape(showTBS and bullishTBS, "Bullish TBS", shape.triangleup, location.belowbar, bullTBSColor, size=size.small, text="TBS")
plotshape(showTBS and bearishTBS, "Bearish TBS", shape.triangledown, location.abovebar, bearTBSColor, size=size.small, text="TBS")

//-----------------------------------------------------------------------------}
//CRT (Candle Range Theory) - A-M-D Pattern Detection
//-----------------------------------------------------------------------------{

// CRT Variables
var box accumulationBox = na
var box manipulationBox = na
var box distributionBox = na
var line tp1Line = na
var line tp2Line = na
var label crtLabel = na

// AMD Pattern States
var int crtState = 0  // 0 = none, 1 = accumulation found, 2 = manipulation found, 3 = distribution
var int accumulationBar = 0
var float accumulationHigh = 0.0
var float accumulationLow = 0.0
var int manipulationBar = 0
var bool isBullishCRT = false

if showCRT
    // Detect Accumulation: Look for ranging candle (small body relative to previous candles)
    bodySize = math.abs(close - open)
    prevBodySize = math.abs(close[1] - open[1])
    candleRange = high - low

    // Accumulation criteria: Relatively small body, defined range
    isAccumulation = bodySize < prevBodySize * 0.8 and candleRange > 0

    // Detect Manipulation (Turtle Soup): Next candle sweeps high/low but closes inside
    isManipulation = false
    isBullishManip = false

    if crtState == 1 and bar_index > accumulationBar
        // Check if current candle swept accumulation range
        sweptLow = low < accumulationLow and close > accumulationLow
        sweptHigh = high > accumulationHigh and close < accumulationHigh

        // Manipulation candle must close inside accumulation range
        closedInside = close >= accumulationLow and close <= accumulationHigh

        if (sweptLow or sweptHigh) and closedInside
            isManipulation := true
            isBullishManip := sweptLow  // Swept low = bullish (expecting upward distribution)
            manipulationBar := bar_index
            crtState := 2

    // Detect Distribution: Strong directional move after manipulation
    isDistribution = false

    if crtState == 2 and bar_index > manipulationBar
        // Bullish distribution: Strong bullish candle after bullish manipulation
        strongBullish = close > open and bodySize > candleRange * 0.6
        strongBearish = close < open and bodySize > candleRange * 0.6

        if isBullishCRT and strongBullish
            isDistribution := true
        else if not isBullishCRT and strongBearish
            isDistribution := true

        if isDistribution
            crtState := 3

    // Start new pattern on accumulation
    if isAccumulation and crtState == 0
        accumulationBar := bar_index
        accumulationHigh := high
        accumulationLow := low
        crtState := 1
        isBullishCRT := false

    // Update manipulation direction
    if isManipulation
        isBullishCRT := isBullishManip

//-----------------------------------------------------------------------------}
//CRT Visual Elements - Boxes and TP Levels
//-----------------------------------------------------------------------------{

if showCRT and crtState >= 1
    // Draw accumulation box
    if crtState == 1 and na(accumulationBox)
        accumulationBox := box.new(accumulationBar, accumulationHigh, bar_index + 10, accumulationLow,
                                   border_color=accumulationColor, bgcolor=accumulationColor,
                                   text="A", text_color=color.white, text_size=size.small)

    // Update accumulation box
    if not na(accumulationBox) and crtState >= 1
        box.set_right(accumulationBox, bar_index + 5)

    // Draw manipulation box
    if crtState == 2 and na(manipulationBox)
        manipulationBox := box.new(manipulationBar, high, manipulationBar + 5, low,
                                   border_color=manipulationColor, bgcolor=manipulationColor,
                                   text="M", text_color=color.white, text_size=size.small)

    // Draw distribution box and TP levels
    if crtState == 3
        distColor = isBullishCRT ? distributionColor : distributionBearColor
        if na(distributionBox)
            distributionBox := box.new(bar_index, high, bar_index + 10, low,
                                       border_color=distColor, bgcolor=distColor,
                                       text="D", text_color=color.white, text_size=size.small)

        // Calculate TP levels based on accumulation range
        accRange = accumulationHigh - accumulationLow

        if showTP
            if isBullishCRT
                // Bullish TPs: 50% and 100% above accumulation high
                tp1Price = accumulationHigh + (accRange * 0.5)
                tp2Price = accumulationHigh + accRange

                if na(tp1Line)
                    tp1Line := line.new(accumulationBar, tp1Price, bar_index + 20, tp1Price,
                                       color=tp1Color, width=2, style=line.style_dashed)
                    tp2Line := line.new(accumulationBar, tp2Price, bar_index + 20, tp2Price,
                                       color=tp2Color, width=2, style=line.style_dashed)
                else
                    line.set_x2(tp1Line, bar_index + 20)
                    line.set_x2(tp2Line, bar_index + 20)
            else
                // Bearish TPs: 50% and 100% below accumulation low
                tp1Price = accumulationLow - (accRange * 0.5)
                tp2Price = accumulationLow - accRange

                if na(tp1Line)
                    tp1Line := line.new(accumulationBar, tp1Price, bar_index + 20, tp1Price,
                                       color=tp1Color, width=2, style=line.style_dashed)
                    tp2Line := line.new(accumulationBar, tp2Price, bar_index + 20, tp2Price,
                                       color=tp2Color, width=2, style=line.style_dashed)
                else
                    line.set_x2(tp1Line, bar_index + 20)
                    line.set_x2(tp2Line, bar_index + 20)

        // Reset pattern after distribution completes
        if bar_index > manipulationBar + 10
            crtState := 0
            accumulationBox := na
            manipulationBox := na
            distributionBox := na
            tp1Line := na
            tp2Line := na

//-----------------------------------------------------------------------------}
//Combined Entry/Exit Signals
//-----------------------------------------------------------------------------{

// Turtle System 1 (20-period) entries
turtle20Long = close > donchian20High[1]
turtle20Short = close < donchian20Low[1]

// Turtle System 2 (55-period) entries
turtle55Long = close > donchian55High[1]
turtle55Short = close < donchian55Low[1]

// Exit signals (10-period for System 1, 20-period for System 2)
exit10High = ta.highest(high, 10)
exit10Low = ta.lowest(low, 10)

exitLong = close < exit10Low[1]
exitShort = close > exit10High[1]

// Combined signals: TBS + CRT + Turtle
var bool combinedLongSignal = false
var bool combinedShortSignal = false

if combineSignals
    // Require TBS confirmation + Turtle breakout
    combinedLongSignal := bullishTBS and (turtle20Long or turtle55Long)
    combinedShortSignal := bearishTBS and (turtle20Short or turtle55Short)
else
    // Just use Turtle breakouts
    combinedLongSignal := turtle20Long or turtle55Long
    combinedShortSignal := turtle20Short or turtle55Short

// Plot entry signals
plotshape(showEntrySignals and combinedLongSignal, "Long Entry", shape.circle, location.belowbar, color.new(color.green, 0), size=size.normal, text="LONG")
plotshape(showEntrySignals and combinedShortSignal, "Short Entry", shape.circle, location.abovebar, color.new(color.red, 0), size=size.normal, text="SHORT")

// Plot exit signals
plotshape(showExitSignals and exitLong, "Exit Long", shape.xcross, location.abovebar, color.new(color.red, 30), size=size.tiny, text="Exit")
plotshape(showExitSignals and exitShort, "Exit Short", shape.xcross, location.belowbar, color.new(color.green, 30), size=size.tiny, text="Exit")

//-----------------------------------------------------------------------------}
//Multi-Timeframe Intrabar
//-----------------------------------------------------------------------------{

// Function to convert string input to label style
getLabelStyle(styleString) =>
    switch styleString
        "None" => label.style_none
        "Label Up" => label.style_label_up
        "Label Down" => label.style_label_down
        "Label Left" => label.style_label_left
        "Label Right" => label.style_label_right
        "Label Center" => label.style_label_center
        "Triangle Up" => label.style_triangleup
        "Triangle Down" => label.style_triangledown
        "Flag" => label.style_flag
        "Circle" => label.style_circle
        "Square" => label.style_square
        "Diamond" => label.style_diamond
        "Cross" => label.style_cross
        "X-Cross" => label.style_xcross
        "Arrow Up" => label.style_arrowup
        "Arrow Down" => label.style_arrowdown
        => label.style_label_up

// Function to convert string input to size
getLabelSize(sizeString) =>
    switch sizeString
        "Auto" => size.auto
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        "Huge" => size.huge
        => size.auto

// Modified process_tf function
process_tf(tf) =>
    var float rangeHigh = na
    var float rangeLow = na
    var float rangeMid = na
    var int rangeStart = 0
    var bool inConsolidation = true
    var bool bullishTouch = false
    var bool bearishTouch = false

    [tfOpen, tfHigh, tfLow, tfClose, tfTime] = request.security(syminfo.tickerid, tf, [open, high, low, close, time], barmerge.gaps_off, barmerge.lookahead_on)

    newBar = ta.change(tfTime) != 0

    tfUp = tfHigh
    tfDown = tfLow
    tfChildUp = tfOpen > tfClose ? tfOpen : tfClose
    tfChildDown = tfOpen > tfClose ? tfClose : tfOpen

    if newBar
        upControl = tfChildUp > rangeHigh and bar_index - rangeStart > minbars and bar_index - rangeStart <= maxbars
        downControl = tfChildDown < rangeLow and bar_index - rangeStart > minbars and bar_index - rangeStart <= maxbars

        if (upControl or downControl)
            inConsolidation := false

        if (inConsolidation and tfChildDown <= rangeHigh and tfChildDown >= rangeLow and tfChildUp <= rangeHigh and tfChildUp >= rangeLow and bar_index > 1)
            rangeStart := rangeStart
        else
            rangeHigh := tfHigh
            rangeLow := tfLow
            rangeStart := bar_index
            inConsolidation := true

        if not inConsolidation and (bar_index - rangeStart > maxbars or bar_index - rangeStart < minbars)
            inConsolidation := true

        rangeMid := (rangeHigh + rangeLow) / 2
        bullishTouch := false
        bearishTouch := false

    if inConsolidation
        bullishWickTouch = low < rangeLow and close > rangeLow and high < rangeHigh
        bullishBodyTouch = open < rangeLow and close > rangeLow
        bearishWickTouch = high > rangeHigh and close < rangeHigh and low > rangeLow
        bearishBodyTouch = open > rangeHigh and close < rangeHigh

        bullishTouch := (use_wick_touch and bullishWickTouch) or (use_body_touch and bullishBodyTouch)
        bearishTouch := (use_wick_touch and bearishWickTouch) or (use_body_touch and bearishBodyTouch)

    [rangeHigh, rangeLow, rangeMid, rangeStart, inConsolidation, newBar, bullishTouch, bearishTouch]

// Process data for each timeframe
[high1, low1, mid1, start1, inRange1, newBar1, bullishTouch1, bearishTouch1] = process_tf(tf1)
[high2, low2, mid2, start2, inRange2, newBar2, bullishTouch2, bearishTouch2] = process_tf(tf2)
[high3, low3, mid3, start3, inRange3, newBar3, bullishTouch3, bearishTouch3] = process_tf(tf3)
[high4, low4, mid4, start4, inRange4, newBar4, bullishTouch4, bearishTouch4] = process_tf(tf4)
[high5, low5, mid5, start5, inRange5, newBar5, bullishTouch5, bearishTouch5] = process_tf(tf5)
[high6, low6, mid6, start6, inRange6, newBar6, bullishTouch6, bearishTouch6] = process_tf(tf6)
[high7, low7, mid7, start7, inRange7, newBar7, bullishTouch7, bearishTouch7] = process_tf(tf7)

// Modified plot_lines function
plot_lines(tfColor, midColor, high, low, mid, start, inRange, newBar, useMid, bullishTouch, bearishTouch, tfName) =>
    var line highLine = na
    var line lowLine = na
    var line midLine = na
    var label highLabel = na
    var label lowLabel = na

    if newBar and inRange
        if not na(highLine)
            line.delete(highLine)
            line.delete(lowLine)
            line.delete(midLine)
        if not na(highLabel)
            label.delete(highLabel)
            label.delete(lowLabel)

        validStart = math.max(start, 0)
        highLine := line.new(validStart, high, bar_index, high, color=tfColor, width=hllinewidth)
        lowLine := line.new(validStart, low, bar_index, low, color=tfColor, width=hllinewidth)
        if useMid
            midLine := line.new(validStart, mid, bar_index, mid, color=midColor, width=midlinewidth, style=line.style_dashed)

        if show_eol_labels
            highLabel := label.new(bar_index + eol_label_offset, high, text=tfName + " High", color=color.new(tfColor, 70), textcolor=tfColor, style=label.style_none, size=size.small)
            lowLabel := label.new(bar_index + eol_label_offset, low, text=tfName + " Low", color=color.new(tfColor, 70), textcolor=tfColor, style=label.style_none, size=size.small)

    if not na(highLine) and inRange
        line.set_x2(highLine, bar_index)
        line.set_x2(lowLine, bar_index)
        if useMid and not na(midLine)
            line.set_x2(midLine, bar_index)

        if show_eol_labels
            label.set_x(highLabel, bar_index + eol_label_offset)
            label.set_y(highLabel, high)
            label.set_x(lowLabel, bar_index + eol_label_offset)
            label.set_y(lowLabel, low)

    [bullishTouch, bearishTouch]

// Plot lines for each timeframe
if use_tf1
    [bullishTouch1, bearishTouch1] = plot_lines(tf1_color, tf1_mid_color, high1, low1, mid1, start1, inRange1, newBar1, use_tf1_mid, bullishTouch1, bearishTouch1, "M30")
if use_tf2
    [bullishTouch2, bearishTouch2] = plot_lines(tf2_color, tf2_mid_color, high2, low2, mid2, start2, inRange2, newBar2, use_tf2_mid, bullishTouch2, bearishTouch2, "H1")
if use_tf3
    [bullishTouch3, bearishTouch3] = plot_lines(tf3_color, tf3_mid_color, high3, low3, mid3, start3, inRange3, newBar3, use_tf3_mid, bullishTouch3, bearishTouch3, "H2")
if use_tf4
    [bullishTouch4, bearishTouch4] = plot_lines(tf4_color, tf4_mid_color, high4, low4, mid4, start4, inRange4, newBar4, use_tf4_mid, bullishTouch4, bearishTouch4, "H4")
if use_tf5
    [bullishTouch5, bearishTouch5] = plot_lines(tf5_color, tf5_mid_color, high5, low5, mid5, start5, inRange5, newBar5, use_tf5_mid, bullishTouch5, bearishTouch5, "D")
if use_tf6
    [bullishTouch6, bearishTouch6] = plot_lines(tf6_color, tf6_mid_color, high6, low6, mid6, start6, inRange6, newBar6, use_tf6_mid, bullishTouch6, bearishTouch6, "W")
if use_tf7
    [bullishTouch7, bearishTouch7] = plot_lines(tf7_color, tf7_mid_color, high7, low7, mid7, start7, inRange7, newBar7, use_tf7_mid, bullishTouch7, bearishTouch7, "M")

// Optimized label management
var label[] labels = array.new_label()

manageLabelCount(labelText, y, bgColor, textColor, style, size) =>
    if array.size(labels) >= max_labels
        label.delete(array.shift(labels))
    newLabel = label.new(bar_index, y, labelText, color=bgColor, textcolor=textColor, style=style, size=size)
    array.push(labels, newLabel)

// Function to check and create labels for a timeframe
checkAndCreateLabel(show, bullishTouch, bearishTouch, tfText) =>
    if show and bullishTouch
        manageLabelCount("BT-" + tfText, low, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
    if show and bearishTouch
        manageLabelCount("BT-" + tfText, high, bearishBgColor, bearishTextColor, getLabelStyle(bearishLabelStyle), getLabelSize(labelSize))

// Apply labels for each timeframe
checkAndCreateLabel(show_m30_labels, bullishTouch1, bearishTouch1, "M30")
checkAndCreateLabel(show_h1_labels, bullishTouch2, bearishTouch2, "H1")
checkAndCreateLabel(show_h2_labels, bullishTouch3, bearishTouch3, "H2")
checkAndCreateLabel(show_h4_labels, bullishTouch4, bearishTouch4, "H4")
checkAndCreateLabel(show_daily_labels, bullishTouch5, bearishTouch5, "D")
checkAndCreateLabel(show_weekly_labels, bullishTouch6, bearishTouch6, "W")
checkAndCreateLabel(show_monthly_labels, bullishTouch7, bearishTouch7, "M")

//-----------------------------------------------------------------------------}
//VWAP
//-----------------------------------------------------------------------------{

var float vwapSum = 0.0
var float volumeSum = 0.0
var float vwapValue = na

// Reset VWAP at the start of each day
newDay = ta.change(time('D'))

if newDay
    vwapSum := 0.0
    volumeSum := 0.0

// Calculate VWAP
typicalPrice = (high + low + close) / 3
vwapSum += typicalPrice * volume
volumeSum += volume

if volumeSum != 0
    vwapValue := vwapSum / volumeSum

// Plot VWAP
plot(showVWAP ? vwapValue : na, "VWAP", color=vwapColor, linewidth=vwapLineWidth)

//-----------------------------------------------------------------------------}
//SMT Divergence
//-----------------------------------------------------------------------------{

if showSMT
    // Get data from second symbol
    [smtOpen, smtHigh, smtLow, smtClose] = request.security(smtSymbol, timeframe.period, [open, high, low, close])

    // Fractal detection
    upPivot = bool(ta.pivothigh(smtPivotPeriod, smtPivotPeriod))
    downPivot = bool(ta.pivotlow(smtPivotPeriod, smtPivotPeriod))

    // Bearish Divergence Data
    highLastPrice = ta.valuewhen(upPivot, high[smtPivotPeriod], 0)
    highPerPrice = ta.valuewhen(upPivot, high[smtPivotPeriod], 1)

    highLastHist = ta.valuewhen(upPivot, smtHigh[smtPivotPeriod], 0)
    highPerHist = ta.valuewhen(upPivot, smtHigh[smtPivotPeriod], 1)

    highLastBar = ta.valuewhen(upPivot, bar_index[smtPivotPeriod], 0)
    highPerBar = ta.valuewhen(upPivot, bar_index[smtPivotPeriod], 1)

    timeConditionBear = (highLastBar + 30) > bar_index

    // Bearish Divergence Detector
    lastBearishDivergence = if highLastHist > 0 and highPerHist > 0 and timeConditionBear and (highLastBar - highPerBar) < 30
        ((highLastPrice > highPerPrice) and (highLastHist < highPerHist)) or ((highLastPrice < highPerPrice) and (highLastHist > highPerHist))
    else
        false

    // Bullish Divergence Data
    lowLastPrice = ta.valuewhen(downPivot, low[smtPivotPeriod], 0)
    lowPerPrice = ta.valuewhen(downPivot, low[smtPivotPeriod], 1)

    lowLastHist = ta.valuewhen(downPivot, smtLow[smtPivotPeriod], 0)
    lowPerHist = ta.valuewhen(downPivot, smtLow[smtPivotPeriod], 1)

    lowLastBar = ta.valuewhen(downPivot, bar_index[smtPivotPeriod], 0)
    lowPerBar = ta.valuewhen(downPivot, bar_index[smtPivotPeriod], 1)

    timeConditionBull = (lowLastBar + 30) > bar_index

    // Bullish Divergence Detector
    lastBullishDivergence = if lowLastHist > 0 and lowPerHist > 0 and timeConditionBull and (lowLastBar - lowPerBar) < 30
        ((lowLastPrice < lowPerPrice) and (lowLastHist > lowPerHist)) or ((lowLastPrice > lowPerPrice) and (lowLastHist < lowPerHist))
    else
        false

    // Draw lines and labels
    var line smtBuLine = na
    var label smtBuLabel = na
    var line smtBeLine = na
    var label smtBeLabel = na

    if lastBullishDivergence
        if showBullSMTLine
            smtBuLine := line.new(lowPerBar, lowPerPrice, lowLastBar, lowLastPrice, color=color.black, width=1, style=line.style_dashed)
        if showBullSMTLabel
            smtBuLabel := label.new(lowLastBar, lowLastPrice, '+SMT', color=color.green, textcolor=color.white, size=size.tiny, style=label.style_label_up)

    if lastBearishDivergence
        if showBearSMTLine
            smtBeLine := line.new(highPerBar, highPerPrice, highLastBar, highLastPrice, color=color.black, width=1, style=line.style_dashed)
        if showBearSMTLabel
            smtBeLabel := label.new(highLastBar, highLastPrice, '-SMT', color=color.red, textcolor=color.white, size=size.tiny, style=label.style_label_down)


//-----------------------------------------------------------------------------}
//No Wick Candlestick Detection
//-----------------------------------------------------------------------------{

// Function to check for bullish candles with no bottom wick
bullishNoBottomWick = showNoWick and (open == low and close > open)

// Function to check for bearish candles with no top wick
bearishNoTopWick = showNoWick and (open == high and close < open)

// Plot triangles below bullish candles with no bottom wick
plotshape(showNoWickShapes and bullishNoBottomWick, location=location.belowbar, color=noWickBullColor, style=shape.triangleup, size=size.small, title="Bullish No Bottom Wick")

// Plot triangles above bearish candles with no top wick
plotshape(showNoWickShapes and bearishNoTopWick, location=location.abovebar, color=noWickBearColor, style=shape.triangledown, size=size.small, title="Bearish No Top Wick")

// Calculate number of bars to the right based on timeframe
barsToRight = timeframe.multiplier

// Draw lines and labels for compensation levels
var line noWickLine = na
var label noWickLabel = na

if showNoWickLines and (bullishNoBottomWick or bearishNoTopWick)
    // Delete previous line and label
    if not na(noWickLine)
        line.delete(noWickLine)
    if not na(noWickLabel)
        label.delete(noWickLabel)

    // Draw line from opening price to the right
    noWickLine := line.new(x1=bar_index, y1=open, x2=bar_index + barsToRight, y2=open, color=noWickLineColor, width=1, style=line.style_solid)

    // Add label to display "Compensation" next to the line
    if showNoWickLabels
        noWickLabel := label.new(x=bar_index + barsToRight + 1, y=open, text="Compensation", style=label.style_label_left, color=noWickLineColor, size=size.small)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{

alertcondition(combinedLongSignal, "Long Entry Signal", "Complete ICT System: Long Entry Signal")
alertcondition(combinedShortSignal, "Short Entry Signal", "Complete ICT System: Short Entry Signal")
alertcondition(bullishTBS, "Bullish Turtle Soup", "Bullish Turtle Soup Detected")
alertcondition(bearishTBS, "Bearish Turtle Soup", "Bearish Turtle Soup Detected")
alertcondition(exitLong, "Exit Long", "Exit Long Position")
alertcondition(exitShort, "Exit Short", "Exit Short Position")
